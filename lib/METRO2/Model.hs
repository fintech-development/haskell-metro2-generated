{-
   METRO2 API

   Moov Metro2 ([Automated Clearing House](https://en.wikipedia.org/wiki/Automated_Clearing_House)) implements an HTTP API for creating, parsing and validating Metro2 files. Metro2 is an open-source consumer credit history report for credit report file creation and validation.

   OpenAPI Version: 3.0.2
   METRO2 API API version: v1
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : METRO2.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module METRO2.Model where

import Network.Integrated.HTTP.Core
import Network.Integrated.HTTP.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** File2
newtype File2 = File2 { unFile2 :: FilePath } deriving (P.Eq, P.Show)

-- ** Format
newtype Format = Format { unFormat :: E'Format } deriving (P.Eq, P.Show)

-- ** Format2
newtype Format2 = Format2 { unFormat2 :: E'Format } deriving (P.Eq, P.Show)

-- ** Generate
newtype Generate = Generate { unGenerate :: Bool } deriving (P.Eq, P.Show)

-- ** Newline
newtype Newline = Newline { unNewline :: Bool } deriving (P.Eq, P.Show)

-- ** ParamType
newtype ParamType = ParamType { unParamType :: E'Type } deriving (P.Eq, P.Show)

-- * Models


-- ** BaseSegment
-- | BaseSegment
data BaseSegment = BaseSegment
  { baseSegmentBlockDescriptorWord :: !(Maybe Int) -- ^ "blockDescriptorWord"
  , baseSegmentRecordDescriptorWord :: !(Int) -- ^ /Required/ "recordDescriptorWord"
  , baseSegmentTimeStamp :: !(Maybe DateTime) -- ^ "timeStamp"
  , baseSegmentIdentificationNumber :: !(Text) -- ^ /Required/ "identificationNumber"
  , baseSegmentCycleIdentifier :: !(Maybe Text) -- ^ "cycleIdentifier"
  , baseSegmentConsumerAccountNumber :: !(Text) -- ^ /Required/ "consumerAccountNumber"
  , baseSegmentPortfolioType :: !(Maybe E'PortfolioType) -- ^ "portfolioType"
  , baseSegmentAccountType :: !(Text) -- ^ /Required/ "accountType"
  , baseSegmentDateOpened :: !(Maybe DateTime) -- ^ "dateOpened"
  , baseSegmentCreditLimit :: !(Maybe Int) -- ^ "creditLimit"
  , baseSegmentHighestCredit :: !(Int) -- ^ /Required/ "highestCredit"
  , baseSegmentTermsDuration :: !(Text) -- ^ /Required/ "termsDuration"
  , baseSegmentTermsFrequency :: !(Maybe E'TermsFrequency) -- ^ "termsFrequency"
  , baseSegmentScheduledMonthlyPaymentAmount :: !(Maybe Int) -- ^ "scheduledMonthlyPaymentAmount"
  , baseSegmentActualPaymentAmount :: !(Maybe Int) -- ^ "actualPaymentAmount"
  , baseSegmentAccountStatus :: !(E'AccountStatus) -- ^ /Required/ "accountStatus"
  , baseSegmentPaymentRating :: !(Maybe E'PaymentRating) -- ^ "paymentRating"
  , baseSegmentPaymentHistoryProfile :: !(E'PaymentHistoryProfile) -- ^ /Required/ "paymentHistoryProfile"
  , baseSegmentSpecialComment :: !(Maybe Text) -- ^ "specialComment"
  , baseSegmentComplianceConditionCode :: !(Maybe Text) -- ^ "complianceConditionCode"
  , baseSegmentCurrentBalance :: !(Int) -- ^ /Required/ "currentBalance"
  , baseSegmentAmountPastDue :: !(Maybe Int) -- ^ "amountPastDue"
  , baseSegmentOriginalChargeOffAmount :: !(Maybe Int) -- ^ "originalChargeOffAmount"
  , baseSegmentDateAccountInformation :: !(DateTime) -- ^ /Required/ "dateAccountInformation"
  , baseSegmentDateFirstDelinquency :: !(Maybe DateTime) -- ^ "dateFirstDelinquency"
  , baseSegmentDateClosed :: !(Maybe DateTime) -- ^ "dateClosed"
  , baseSegmentDateLastPayment :: !(Maybe DateTime) -- ^ "dateLastPayment"
  , baseSegmentInterestTypeIndicator :: !(Maybe Text) -- ^ "interestTypeIndicator"
  , baseSegmentSurname :: !(Text) -- ^ /Required/ "surname"
  , baseSegmentFirstName :: !(Text) -- ^ /Required/ "firstName"
  , baseSegmentMiddleName :: !(Maybe Text) -- ^ "middleName"
  , baseSegmentGenerationCode :: !(Maybe E'GenerationCode) -- ^ "generationCode"
  , baseSegmentSocialSecurityNumber :: !(Int) -- ^ /Required/ "socialSecurityNumber"
  , baseSegmentDateBirth :: !(DateTime) -- ^ /Required/ "dateBirth"
  , baseSegmentTelephoneNumber :: !(Maybe Integer) -- ^ "telephoneNumber"
  , baseSegmentEcoaCode :: !(Text) -- ^ /Required/ "ecoaCode"
  , baseSegmentConsumerInformationIndicator :: !(Maybe Text) -- ^ "consumerInformationIndicator"
  , baseSegmentCountryCode :: !(Maybe Text) -- ^ "countryCode"
  , baseSegmentFirstLineAddress :: !(Text) -- ^ /Required/ "firstLineAddress"
  , baseSegmentSecondLineAddress :: !(Maybe Text) -- ^ "secondLineAddress"
  , baseSegmentCity :: !(Maybe Text) -- ^ "city"
  , baseSegmentState :: !(Text) -- ^ /Required/ "state"
  , baseSegmentZipCode :: !(Text) -- ^ /Required/ "zipCode"
  , baseSegmentAddressIndicator :: !(Maybe E'AddressIndicator) -- ^ "addressIndicator"
  , baseSegmentResidenceCode :: !(Maybe E'ResidenceCode) -- ^ "residenceCode"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BaseSegment
instance A.FromJSON BaseSegment where
  parseJSON = A.withObject "BaseSegment" $ \o ->
    BaseSegment
      <$> (o .:? "blockDescriptorWord")
      <*> (o .:  "recordDescriptorWord")
      <*> (o .:? "timeStamp")
      <*> (o .:  "identificationNumber")
      <*> (o .:? "cycleIdentifier")
      <*> (o .:  "consumerAccountNumber")
      <*> (o .:? "portfolioType")
      <*> (o .:  "accountType")
      <*> (o .:? "dateOpened")
      <*> (o .:? "creditLimit")
      <*> (o .:  "highestCredit")
      <*> (o .:  "termsDuration")
      <*> (o .:? "termsFrequency")
      <*> (o .:? "scheduledMonthlyPaymentAmount")
      <*> (o .:? "actualPaymentAmount")
      <*> (o .:  "accountStatus")
      <*> (o .:? "paymentRating")
      <*> (o .:  "paymentHistoryProfile")
      <*> (o .:? "specialComment")
      <*> (o .:? "complianceConditionCode")
      <*> (o .:  "currentBalance")
      <*> (o .:? "amountPastDue")
      <*> (o .:? "originalChargeOffAmount")
      <*> (o .:  "dateAccountInformation")
      <*> (o .:? "dateFirstDelinquency")
      <*> (o .:? "dateClosed")
      <*> (o .:? "dateLastPayment")
      <*> (o .:? "interestTypeIndicator")
      <*> (o .:  "surname")
      <*> (o .:  "firstName")
      <*> (o .:? "middleName")
      <*> (o .:? "generationCode")
      <*> (o .:  "socialSecurityNumber")
      <*> (o .:  "dateBirth")
      <*> (o .:? "telephoneNumber")
      <*> (o .:  "ecoaCode")
      <*> (o .:? "consumerInformationIndicator")
      <*> (o .:? "countryCode")
      <*> (o .:  "firstLineAddress")
      <*> (o .:? "secondLineAddress")
      <*> (o .:? "city")
      <*> (o .:  "state")
      <*> (o .:  "zipCode")
      <*> (o .:? "addressIndicator")
      <*> (o .:? "residenceCode")

-- | ToJSON BaseSegment
instance A.ToJSON BaseSegment where
  toJSON BaseSegment {..} =
   A.object
      [ "blockDescriptorWord" .= baseSegmentBlockDescriptorWord
      , "recordDescriptorWord" .= baseSegmentRecordDescriptorWord
      , "timeStamp" .= baseSegmentTimeStamp
      , "identificationNumber" .= baseSegmentIdentificationNumber
      , "cycleIdentifier" .= baseSegmentCycleIdentifier
      , "consumerAccountNumber" .= baseSegmentConsumerAccountNumber
      , "portfolioType" .= baseSegmentPortfolioType
      , "accountType" .= baseSegmentAccountType
      , "dateOpened" .= baseSegmentDateOpened
      , "creditLimit" .= baseSegmentCreditLimit
      , "highestCredit" .= baseSegmentHighestCredit
      , "termsDuration" .= baseSegmentTermsDuration
      , "termsFrequency" .= baseSegmentTermsFrequency
      , "scheduledMonthlyPaymentAmount" .= baseSegmentScheduledMonthlyPaymentAmount
      , "actualPaymentAmount" .= baseSegmentActualPaymentAmount
      , "accountStatus" .= baseSegmentAccountStatus
      , "paymentRating" .= baseSegmentPaymentRating
      , "paymentHistoryProfile" .= baseSegmentPaymentHistoryProfile
      , "specialComment" .= baseSegmentSpecialComment
      , "complianceConditionCode" .= baseSegmentComplianceConditionCode
      , "currentBalance" .= baseSegmentCurrentBalance
      , "amountPastDue" .= baseSegmentAmountPastDue
      , "originalChargeOffAmount" .= baseSegmentOriginalChargeOffAmount
      , "dateAccountInformation" .= baseSegmentDateAccountInformation
      , "dateFirstDelinquency" .= baseSegmentDateFirstDelinquency
      , "dateClosed" .= baseSegmentDateClosed
      , "dateLastPayment" .= baseSegmentDateLastPayment
      , "interestTypeIndicator" .= baseSegmentInterestTypeIndicator
      , "surname" .= baseSegmentSurname
      , "firstName" .= baseSegmentFirstName
      , "middleName" .= baseSegmentMiddleName
      , "generationCode" .= baseSegmentGenerationCode
      , "socialSecurityNumber" .= baseSegmentSocialSecurityNumber
      , "dateBirth" .= baseSegmentDateBirth
      , "telephoneNumber" .= baseSegmentTelephoneNumber
      , "ecoaCode" .= baseSegmentEcoaCode
      , "consumerInformationIndicator" .= baseSegmentConsumerInformationIndicator
      , "countryCode" .= baseSegmentCountryCode
      , "firstLineAddress" .= baseSegmentFirstLineAddress
      , "secondLineAddress" .= baseSegmentSecondLineAddress
      , "city" .= baseSegmentCity
      , "state" .= baseSegmentState
      , "zipCode" .= baseSegmentZipCode
      , "addressIndicator" .= baseSegmentAddressIndicator
      , "residenceCode" .= baseSegmentResidenceCode
      ]


-- | Construct a value of type 'BaseSegment' (by applying it's required fields, if any)
mkBaseSegment
  :: Int -- ^ 'baseSegmentRecordDescriptorWord'
  -> Text -- ^ 'baseSegmentIdentificationNumber'
  -> Text -- ^ 'baseSegmentConsumerAccountNumber'
  -> Text -- ^ 'baseSegmentAccountType'
  -> Int -- ^ 'baseSegmentHighestCredit'
  -> Text -- ^ 'baseSegmentTermsDuration'
  -> E'AccountStatus -- ^ 'baseSegmentAccountStatus'
  -> E'PaymentHistoryProfile -- ^ 'baseSegmentPaymentHistoryProfile'
  -> Int -- ^ 'baseSegmentCurrentBalance'
  -> DateTime -- ^ 'baseSegmentDateAccountInformation'
  -> Text -- ^ 'baseSegmentSurname'
  -> Text -- ^ 'baseSegmentFirstName'
  -> Int -- ^ 'baseSegmentSocialSecurityNumber'
  -> DateTime -- ^ 'baseSegmentDateBirth'
  -> Text -- ^ 'baseSegmentEcoaCode'
  -> Text -- ^ 'baseSegmentFirstLineAddress'
  -> Text -- ^ 'baseSegmentState'
  -> Text -- ^ 'baseSegmentZipCode'
  -> BaseSegment
mkBaseSegment baseSegmentRecordDescriptorWord baseSegmentIdentificationNumber baseSegmentConsumerAccountNumber baseSegmentAccountType baseSegmentHighestCredit baseSegmentTermsDuration baseSegmentAccountStatus baseSegmentPaymentHistoryProfile baseSegmentCurrentBalance baseSegmentDateAccountInformation baseSegmentSurname baseSegmentFirstName baseSegmentSocialSecurityNumber baseSegmentDateBirth baseSegmentEcoaCode baseSegmentFirstLineAddress baseSegmentState baseSegmentZipCode =
  BaseSegment
  { baseSegmentBlockDescriptorWord = Nothing
  , baseSegmentRecordDescriptorWord
  , baseSegmentTimeStamp = Nothing
  , baseSegmentIdentificationNumber
  , baseSegmentCycleIdentifier = Nothing
  , baseSegmentConsumerAccountNumber
  , baseSegmentPortfolioType = Nothing
  , baseSegmentAccountType
  , baseSegmentDateOpened = Nothing
  , baseSegmentCreditLimit = Nothing
  , baseSegmentHighestCredit
  , baseSegmentTermsDuration
  , baseSegmentTermsFrequency = Nothing
  , baseSegmentScheduledMonthlyPaymentAmount = Nothing
  , baseSegmentActualPaymentAmount = Nothing
  , baseSegmentAccountStatus
  , baseSegmentPaymentRating = Nothing
  , baseSegmentPaymentHistoryProfile
  , baseSegmentSpecialComment = Nothing
  , baseSegmentComplianceConditionCode = Nothing
  , baseSegmentCurrentBalance
  , baseSegmentAmountPastDue = Nothing
  , baseSegmentOriginalChargeOffAmount = Nothing
  , baseSegmentDateAccountInformation
  , baseSegmentDateFirstDelinquency = Nothing
  , baseSegmentDateClosed = Nothing
  , baseSegmentDateLastPayment = Nothing
  , baseSegmentInterestTypeIndicator = Nothing
  , baseSegmentSurname
  , baseSegmentFirstName
  , baseSegmentMiddleName = Nothing
  , baseSegmentGenerationCode = Nothing
  , baseSegmentSocialSecurityNumber
  , baseSegmentDateBirth
  , baseSegmentTelephoneNumber = Nothing
  , baseSegmentEcoaCode
  , baseSegmentConsumerInformationIndicator = Nothing
  , baseSegmentCountryCode = Nothing
  , baseSegmentFirstLineAddress
  , baseSegmentSecondLineAddress = Nothing
  , baseSegmentCity = Nothing
  , baseSegmentState
  , baseSegmentZipCode
  , baseSegmentAddressIndicator = Nothing
  , baseSegmentResidenceCode = Nothing
  }

-- ** DataRecord
-- | DataRecord
data DataRecord = DataRecord
  { dataRecordBase :: !(BaseSegment) -- ^ /Required/ "base"
  , dataRecordJ1 :: !(Maybe [J1Segment]) -- ^ "j1"
  , dataRecordJ2 :: !(Maybe [J2Segment]) -- ^ "j2"
  , dataRecordK1 :: !(Maybe K1Segment) -- ^ "k1"
  , dataRecordK2 :: !(Maybe K2Segment) -- ^ "k2"
  , dataRecordK3 :: !(Maybe K3Segment) -- ^ "k3"
  , dataRecordK4 :: !(Maybe K4Segment) -- ^ "k4"
  , dataRecordL1 :: !(Maybe L1Segment) -- ^ "l1"
  , dataRecordN1 :: !(Maybe N1Segment) -- ^ "n1"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DataRecord
instance A.FromJSON DataRecord where
  parseJSON = A.withObject "DataRecord" $ \o ->
    DataRecord
      <$> (o .:  "base")
      <*> (o .:? "j1")
      <*> (o .:? "j2")
      <*> (o .:? "k1")
      <*> (o .:? "k2")
      <*> (o .:? "k3")
      <*> (o .:? "k4")
      <*> (o .:? "l1")
      <*> (o .:? "n1")

-- | ToJSON DataRecord
instance A.ToJSON DataRecord where
  toJSON DataRecord {..} =
   A.object
      [ "base" .= dataRecordBase
      , "j1" .= dataRecordJ1
      , "j2" .= dataRecordJ2
      , "k1" .= dataRecordK1
      , "k2" .= dataRecordK2
      , "k3" .= dataRecordK3
      , "k4" .= dataRecordK4
      , "l1" .= dataRecordL1
      , "n1" .= dataRecordN1
      ]


-- | Construct a value of type 'DataRecord' (by applying it's required fields, if any)
mkDataRecord
  :: BaseSegment -- ^ 'dataRecordBase'
  -> DataRecord
mkDataRecord dataRecordBase =
  DataRecord
  { dataRecordBase
  , dataRecordJ1 = Nothing
  , dataRecordJ2 = Nothing
  , dataRecordK1 = Nothing
  , dataRecordK2 = Nothing
  , dataRecordK3 = Nothing
  , dataRecordK4 = Nothing
  , dataRecordL1 = Nothing
  , dataRecordN1 = Nothing
  }

-- ** File
-- | File
data File = File
  { fileHeader :: !(HeaderRecord) -- ^ /Required/ "header"
  , fileData :: !(Maybe [DataRecord]) -- ^ "data"
  , fileTrailer :: !(TrailerRecord) -- ^ /Required/ "trailer"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON File
instance A.FromJSON File where
  parseJSON = A.withObject "File" $ \o ->
    File
      <$> (o .:  "header")
      <*> (o .:? "data")
      <*> (o .:  "trailer")

-- | ToJSON File
instance A.ToJSON File where
  toJSON File {..} =
   A.object
      [ "header" .= fileHeader
      , "data" .= fileData
      , "trailer" .= fileTrailer
      ]


-- | Construct a value of type 'File' (by applying it's required fields, if any)
mkFile
  :: HeaderRecord -- ^ 'fileHeader'
  -> TrailerRecord -- ^ 'fileTrailer'
  -> File
mkFile fileHeader fileTrailer =
  File
  { fileHeader
  , fileData = Nothing
  , fileTrailer
  }

-- ** HeaderRecord
-- | HeaderRecord
data HeaderRecord = HeaderRecord
  { headerRecordBlockDescriptorWord :: !(Maybe Int) -- ^ "blockDescriptorWord"
  , headerRecordRecordDescriptorWord :: !(Int) -- ^ /Required/ "recordDescriptorWord"
  , headerRecordRecordIdentifier :: !(E'RecordIdentifier) -- ^ /Required/ "recordIdentifier"
  , headerRecordCycleIdentifier :: !(Maybe Text) -- ^ "cycleIdentifier"
  , headerRecordInnovisProgramIdentifier :: !(Maybe Text) -- ^ "innovisProgramIdentifier"
  , headerRecordEquifaxProgramIdentifier :: !(Maybe Text) -- ^ "equifaxProgramIdentifier"
  , headerRecordExperianProgramIdentifier :: !(Maybe Text) -- ^ "experianProgramIdentifier"
  , headerRecordTransUnionProgramIdentifier :: !(Maybe Text) -- ^ "transUnionProgramIdentifier"
  , headerRecordActivityDate :: !(DateTime) -- ^ /Required/ "activityDate"
  , headerRecordDateCreated :: !(DateTime) -- ^ /Required/ "dateCreated"
  , headerRecordProgramDate :: !(Maybe DateTime) -- ^ "programDate"
  , headerRecordProgramRevisionDate :: !(Maybe DateTime) -- ^ "programRevisionDate"
  , headerRecordReporterName :: !(Text) -- ^ /Required/ "reporterName"
  , headerRecordReporterAddress :: !(Text) -- ^ /Required/ "reporterAddress"
  , headerRecordReporterTelephoneNumber :: !(Maybe Integer) -- ^ "reporterTelephoneNumber"
  , headerRecordSoftwareVendorName :: !(Maybe Text) -- ^ "softwareVendorName"
  , headerRecordSoftwareVersionNumber :: !(Maybe Text) -- ^ "softwareVersionNumber"
  , headerRecordPrbcProgramIdentifier :: !(Maybe Text) -- ^ "prbcProgramIdentifier"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON HeaderRecord
instance A.FromJSON HeaderRecord where
  parseJSON = A.withObject "HeaderRecord" $ \o ->
    HeaderRecord
      <$> (o .:? "blockDescriptorWord")
      <*> (o .:  "recordDescriptorWord")
      <*> (o .:  "recordIdentifier")
      <*> (o .:? "cycleIdentifier")
      <*> (o .:? "innovisProgramIdentifier")
      <*> (o .:? "equifaxProgramIdentifier")
      <*> (o .:? "experianProgramIdentifier")
      <*> (o .:? "transUnionProgramIdentifier")
      <*> (o .:  "activityDate")
      <*> (o .:  "dateCreated")
      <*> (o .:? "programDate")
      <*> (o .:? "programRevisionDate")
      <*> (o .:  "reporterName")
      <*> (o .:  "reporterAddress")
      <*> (o .:? "reporterTelephoneNumber")
      <*> (o .:? "softwareVendorName")
      <*> (o .:? "softwareVersionNumber")
      <*> (o .:? "prbcProgramIdentifier")

-- | ToJSON HeaderRecord
instance A.ToJSON HeaderRecord where
  toJSON HeaderRecord {..} =
   A.object
      [ "blockDescriptorWord" .= headerRecordBlockDescriptorWord
      , "recordDescriptorWord" .= headerRecordRecordDescriptorWord
      , "recordIdentifier" .= headerRecordRecordIdentifier
      , "cycleIdentifier" .= headerRecordCycleIdentifier
      , "innovisProgramIdentifier" .= headerRecordInnovisProgramIdentifier
      , "equifaxProgramIdentifier" .= headerRecordEquifaxProgramIdentifier
      , "experianProgramIdentifier" .= headerRecordExperianProgramIdentifier
      , "transUnionProgramIdentifier" .= headerRecordTransUnionProgramIdentifier
      , "activityDate" .= headerRecordActivityDate
      , "dateCreated" .= headerRecordDateCreated
      , "programDate" .= headerRecordProgramDate
      , "programRevisionDate" .= headerRecordProgramRevisionDate
      , "reporterName" .= headerRecordReporterName
      , "reporterAddress" .= headerRecordReporterAddress
      , "reporterTelephoneNumber" .= headerRecordReporterTelephoneNumber
      , "softwareVendorName" .= headerRecordSoftwareVendorName
      , "softwareVersionNumber" .= headerRecordSoftwareVersionNumber
      , "prbcProgramIdentifier" .= headerRecordPrbcProgramIdentifier
      ]


-- | Construct a value of type 'HeaderRecord' (by applying it's required fields, if any)
mkHeaderRecord
  :: Int -- ^ 'headerRecordRecordDescriptorWord'
  -> E'RecordIdentifier -- ^ 'headerRecordRecordIdentifier'
  -> DateTime -- ^ 'headerRecordActivityDate'
  -> DateTime -- ^ 'headerRecordDateCreated'
  -> Text -- ^ 'headerRecordReporterName'
  -> Text -- ^ 'headerRecordReporterAddress'
  -> HeaderRecord
mkHeaderRecord headerRecordRecordDescriptorWord headerRecordRecordIdentifier headerRecordActivityDate headerRecordDateCreated headerRecordReporterName headerRecordReporterAddress =
  HeaderRecord
  { headerRecordBlockDescriptorWord = Nothing
  , headerRecordRecordDescriptorWord
  , headerRecordRecordIdentifier
  , headerRecordCycleIdentifier = Nothing
  , headerRecordInnovisProgramIdentifier = Nothing
  , headerRecordEquifaxProgramIdentifier = Nothing
  , headerRecordExperianProgramIdentifier = Nothing
  , headerRecordTransUnionProgramIdentifier = Nothing
  , headerRecordActivityDate
  , headerRecordDateCreated
  , headerRecordProgramDate = Nothing
  , headerRecordProgramRevisionDate = Nothing
  , headerRecordReporterName
  , headerRecordReporterAddress
  , headerRecordReporterTelephoneNumber = Nothing
  , headerRecordSoftwareVendorName = Nothing
  , headerRecordSoftwareVersionNumber = Nothing
  , headerRecordPrbcProgramIdentifier = Nothing
  }

-- ** J1Segment
-- | J1Segment
data J1Segment = J1Segment
  { j1SegmentSegmentIdentifier :: !(E'SegmentIdentifier) -- ^ /Required/ "segmentIdentifier"
  , j1SegmentSurname :: !(Text) -- ^ /Required/ "surname"
  , j1SegmentFirstName :: !(Text) -- ^ /Required/ "firstName"
  , j1SegmentMiddleName :: !(Maybe Text) -- ^ "middleName"
  , j1SegmentGenerationCode :: !(Maybe E'GenerationCode2) -- ^ "generationCode"
  , j1SegmentSocialSecurityNumber :: !(Int) -- ^ /Required/ "socialSecurityNumber"
  , j1SegmentDateBirth :: !(DateTime) -- ^ /Required/ "dateBirth"
  , j1SegmentTelephoneNumber :: !(Maybe Integer) -- ^ "telephoneNumber"
  , j1SegmentEcoaCode :: !(Text) -- ^ /Required/ "ecoaCode"
  , j1SegmentConsumerInformationIndicator :: !(Maybe Text) -- ^ "consumerInformationIndicator"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON J1Segment
instance A.FromJSON J1Segment where
  parseJSON = A.withObject "J1Segment" $ \o ->
    J1Segment
      <$> (o .:  "segmentIdentifier")
      <*> (o .:  "surname")
      <*> (o .:  "firstName")
      <*> (o .:? "middleName")
      <*> (o .:? "generationCode")
      <*> (o .:  "socialSecurityNumber")
      <*> (o .:  "dateBirth")
      <*> (o .:? "telephoneNumber")
      <*> (o .:  "ecoaCode")
      <*> (o .:? "consumerInformationIndicator")

-- | ToJSON J1Segment
instance A.ToJSON J1Segment where
  toJSON J1Segment {..} =
   A.object
      [ "segmentIdentifier" .= j1SegmentSegmentIdentifier
      , "surname" .= j1SegmentSurname
      , "firstName" .= j1SegmentFirstName
      , "middleName" .= j1SegmentMiddleName
      , "generationCode" .= j1SegmentGenerationCode
      , "socialSecurityNumber" .= j1SegmentSocialSecurityNumber
      , "dateBirth" .= j1SegmentDateBirth
      , "telephoneNumber" .= j1SegmentTelephoneNumber
      , "ecoaCode" .= j1SegmentEcoaCode
      , "consumerInformationIndicator" .= j1SegmentConsumerInformationIndicator
      ]


-- | Construct a value of type 'J1Segment' (by applying it's required fields, if any)
mkJ1Segment
  :: E'SegmentIdentifier -- ^ 'j1SegmentSegmentIdentifier'
  -> Text -- ^ 'j1SegmentSurname'
  -> Text -- ^ 'j1SegmentFirstName'
  -> Int -- ^ 'j1SegmentSocialSecurityNumber'
  -> DateTime -- ^ 'j1SegmentDateBirth'
  -> Text -- ^ 'j1SegmentEcoaCode'
  -> J1Segment
mkJ1Segment j1SegmentSegmentIdentifier j1SegmentSurname j1SegmentFirstName j1SegmentSocialSecurityNumber j1SegmentDateBirth j1SegmentEcoaCode =
  J1Segment
  { j1SegmentSegmentIdentifier
  , j1SegmentSurname
  , j1SegmentFirstName
  , j1SegmentMiddleName = Nothing
  , j1SegmentGenerationCode = Nothing
  , j1SegmentSocialSecurityNumber
  , j1SegmentDateBirth
  , j1SegmentTelephoneNumber = Nothing
  , j1SegmentEcoaCode
  , j1SegmentConsumerInformationIndicator = Nothing
  }

-- ** J2Segment
-- | J2Segment
data J2Segment = J2Segment
  { j2SegmentSegmentIdentifier :: !(E'SegmentIdentifier2) -- ^ /Required/ "segmentIdentifier"
  , j2SegmentSurname :: !(Text) -- ^ /Required/ "surname"
  , j2SegmentFirstName :: !(Text) -- ^ /Required/ "firstName"
  , j2SegmentMiddleName :: !(Maybe Text) -- ^ "middleName"
  , j2SegmentGenerationCode :: !(Maybe E'GenerationCode2) -- ^ "generationCode"
  , j2SegmentSocialSecurityNumber :: !(Int) -- ^ /Required/ "socialSecurityNumber"
  , j2SegmentDateBirth :: !(DateTime) -- ^ /Required/ "dateBirth"
  , j2SegmentTelephoneNumber :: !(Maybe Integer) -- ^ "telephoneNumber"
  , j2SegmentEcoaCode :: !(Text) -- ^ /Required/ "ecoaCode"
  , j2SegmentConsumerInformationIndicator :: !(Maybe Text) -- ^ "consumerInformationIndicator"
  , j2SegmentCountryCode :: !(Maybe Text) -- ^ "countryCode"
  , j2SegmentFirstLineAddress :: !(Text) -- ^ /Required/ "firstLineAddress"
  , j2SegmentSecondLineAddress :: !(Maybe Text) -- ^ "secondLineAddress"
  , j2SegmentCity :: !(Text) -- ^ /Required/ "city"
  , j2SegmentState :: !(Text) -- ^ /Required/ "state"
  , j2SegmentZipCode :: !(Text) -- ^ /Required/ "zipCode"
  , j2SegmentAddressIndicator :: !(Maybe E'AddressIndicator) -- ^ "addressIndicator"
  , j2SegmentResidenceCode :: !(Maybe E'ResidenceCode) -- ^ "residenceCode"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON J2Segment
instance A.FromJSON J2Segment where
  parseJSON = A.withObject "J2Segment" $ \o ->
    J2Segment
      <$> (o .:  "segmentIdentifier")
      <*> (o .:  "surname")
      <*> (o .:  "firstName")
      <*> (o .:? "middleName")
      <*> (o .:? "generationCode")
      <*> (o .:  "socialSecurityNumber")
      <*> (o .:  "dateBirth")
      <*> (o .:? "telephoneNumber")
      <*> (o .:  "ecoaCode")
      <*> (o .:? "consumerInformationIndicator")
      <*> (o .:? "countryCode")
      <*> (o .:  "firstLineAddress")
      <*> (o .:? "secondLineAddress")
      <*> (o .:  "city")
      <*> (o .:  "state")
      <*> (o .:  "zipCode")
      <*> (o .:? "addressIndicator")
      <*> (o .:? "residenceCode")

-- | ToJSON J2Segment
instance A.ToJSON J2Segment where
  toJSON J2Segment {..} =
   A.object
      [ "segmentIdentifier" .= j2SegmentSegmentIdentifier
      , "surname" .= j2SegmentSurname
      , "firstName" .= j2SegmentFirstName
      , "middleName" .= j2SegmentMiddleName
      , "generationCode" .= j2SegmentGenerationCode
      , "socialSecurityNumber" .= j2SegmentSocialSecurityNumber
      , "dateBirth" .= j2SegmentDateBirth
      , "telephoneNumber" .= j2SegmentTelephoneNumber
      , "ecoaCode" .= j2SegmentEcoaCode
      , "consumerInformationIndicator" .= j2SegmentConsumerInformationIndicator
      , "countryCode" .= j2SegmentCountryCode
      , "firstLineAddress" .= j2SegmentFirstLineAddress
      , "secondLineAddress" .= j2SegmentSecondLineAddress
      , "city" .= j2SegmentCity
      , "state" .= j2SegmentState
      , "zipCode" .= j2SegmentZipCode
      , "addressIndicator" .= j2SegmentAddressIndicator
      , "residenceCode" .= j2SegmentResidenceCode
      ]


-- | Construct a value of type 'J2Segment' (by applying it's required fields, if any)
mkJ2Segment
  :: E'SegmentIdentifier2 -- ^ 'j2SegmentSegmentIdentifier'
  -> Text -- ^ 'j2SegmentSurname'
  -> Text -- ^ 'j2SegmentFirstName'
  -> Int -- ^ 'j2SegmentSocialSecurityNumber'
  -> DateTime -- ^ 'j2SegmentDateBirth'
  -> Text -- ^ 'j2SegmentEcoaCode'
  -> Text -- ^ 'j2SegmentFirstLineAddress'
  -> Text -- ^ 'j2SegmentCity'
  -> Text -- ^ 'j2SegmentState'
  -> Text -- ^ 'j2SegmentZipCode'
  -> J2Segment
mkJ2Segment j2SegmentSegmentIdentifier j2SegmentSurname j2SegmentFirstName j2SegmentSocialSecurityNumber j2SegmentDateBirth j2SegmentEcoaCode j2SegmentFirstLineAddress j2SegmentCity j2SegmentState j2SegmentZipCode =
  J2Segment
  { j2SegmentSegmentIdentifier
  , j2SegmentSurname
  , j2SegmentFirstName
  , j2SegmentMiddleName = Nothing
  , j2SegmentGenerationCode = Nothing
  , j2SegmentSocialSecurityNumber
  , j2SegmentDateBirth
  , j2SegmentTelephoneNumber = Nothing
  , j2SegmentEcoaCode
  , j2SegmentConsumerInformationIndicator = Nothing
  , j2SegmentCountryCode = Nothing
  , j2SegmentFirstLineAddress
  , j2SegmentSecondLineAddress = Nothing
  , j2SegmentCity
  , j2SegmentState
  , j2SegmentZipCode
  , j2SegmentAddressIndicator = Nothing
  , j2SegmentResidenceCode = Nothing
  }

-- ** K1Segment
-- | K1Segment
data K1Segment = K1Segment
  { k1SegmentSegmentIdentifier :: !(E'SegmentIdentifier3) -- ^ /Required/ "segmentIdentifier"
  , k1SegmentOriginalCreditorName :: !(Text) -- ^ /Required/ "originalCreditorName"
  , k1SegmentCreditorClassification :: !(E'CreditorClassification) -- ^ /Required/ "creditorClassification"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON K1Segment
instance A.FromJSON K1Segment where
  parseJSON = A.withObject "K1Segment" $ \o ->
    K1Segment
      <$> (o .:  "segmentIdentifier")
      <*> (o .:  "originalCreditorName")
      <*> (o .:  "creditorClassification")

-- | ToJSON K1Segment
instance A.ToJSON K1Segment where
  toJSON K1Segment {..} =
   A.object
      [ "segmentIdentifier" .= k1SegmentSegmentIdentifier
      , "originalCreditorName" .= k1SegmentOriginalCreditorName
      , "creditorClassification" .= k1SegmentCreditorClassification
      ]


-- | Construct a value of type 'K1Segment' (by applying it's required fields, if any)
mkK1Segment
  :: E'SegmentIdentifier3 -- ^ 'k1SegmentSegmentIdentifier'
  -> Text -- ^ 'k1SegmentOriginalCreditorName'
  -> E'CreditorClassification -- ^ 'k1SegmentCreditorClassification'
  -> K1Segment
mkK1Segment k1SegmentSegmentIdentifier k1SegmentOriginalCreditorName k1SegmentCreditorClassification =
  K1Segment
  { k1SegmentSegmentIdentifier
  , k1SegmentOriginalCreditorName
  , k1SegmentCreditorClassification
  }

-- ** K2Segment
-- | K2Segment
data K2Segment = K2Segment
  { k2SegmentSegmentIdentifier :: !(E'SegmentIdentifier4) -- ^ /Required/ "segmentIdentifier"
  , k2SegmentPurchasedIndicator :: !(E'PurchasedIndicator) -- ^ /Required/ "purchasedIndicator"
  , k2SegmentPurchasedName :: !(Text) -- ^ /Required/ "purchasedName"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON K2Segment
instance A.FromJSON K2Segment where
  parseJSON = A.withObject "K2Segment" $ \o ->
    K2Segment
      <$> (o .:  "segmentIdentifier")
      <*> (o .:  "purchasedIndicator")
      <*> (o .:  "purchasedName")

-- | ToJSON K2Segment
instance A.ToJSON K2Segment where
  toJSON K2Segment {..} =
   A.object
      [ "segmentIdentifier" .= k2SegmentSegmentIdentifier
      , "purchasedIndicator" .= k2SegmentPurchasedIndicator
      , "purchasedName" .= k2SegmentPurchasedName
      ]


-- | Construct a value of type 'K2Segment' (by applying it's required fields, if any)
mkK2Segment
  :: E'SegmentIdentifier4 -- ^ 'k2SegmentSegmentIdentifier'
  -> E'PurchasedIndicator -- ^ 'k2SegmentPurchasedIndicator'
  -> Text -- ^ 'k2SegmentPurchasedName'
  -> K2Segment
mkK2Segment k2SegmentSegmentIdentifier k2SegmentPurchasedIndicator k2SegmentPurchasedName =
  K2Segment
  { k2SegmentSegmentIdentifier
  , k2SegmentPurchasedIndicator
  , k2SegmentPurchasedName
  }

-- ** K3Segment
-- | K3Segment
data K3Segment = K3Segment
  { k3SegmentSegmentIdentifier :: !(E'SegmentIdentifier5) -- ^ /Required/ "segmentIdentifier"
  , k3SegmentAgencyIdentifier :: !(Maybe E'AgencyIdentifier) -- ^ "agencyIdentifier"
  , k3SegmentAccountNumber :: !(Maybe Text) -- ^ "accountNumber"
  , k3SegmentMortgageIdentificationNumber :: !(Maybe Text) -- ^ "mortgageIdentificationNumber"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON K3Segment
instance A.FromJSON K3Segment where
  parseJSON = A.withObject "K3Segment" $ \o ->
    K3Segment
      <$> (o .:  "segmentIdentifier")
      <*> (o .:? "agencyIdentifier")
      <*> (o .:? "accountNumber")
      <*> (o .:? "mortgageIdentificationNumber")

-- | ToJSON K3Segment
instance A.ToJSON K3Segment where
  toJSON K3Segment {..} =
   A.object
      [ "segmentIdentifier" .= k3SegmentSegmentIdentifier
      , "agencyIdentifier" .= k3SegmentAgencyIdentifier
      , "accountNumber" .= k3SegmentAccountNumber
      , "mortgageIdentificationNumber" .= k3SegmentMortgageIdentificationNumber
      ]


-- | Construct a value of type 'K3Segment' (by applying it's required fields, if any)
mkK3Segment
  :: E'SegmentIdentifier5 -- ^ 'k3SegmentSegmentIdentifier'
  -> K3Segment
mkK3Segment k3SegmentSegmentIdentifier =
  K3Segment
  { k3SegmentSegmentIdentifier
  , k3SegmentAgencyIdentifier = Nothing
  , k3SegmentAccountNumber = Nothing
  , k3SegmentMortgageIdentificationNumber = Nothing
  }

-- ** K4Segment
-- | K4Segment
data K4Segment = K4Segment
  { k4SegmentSegmentIdentifier :: !(E'SegmentIdentifier6) -- ^ /Required/ "segmentIdentifier"
  , k4SegmentSpecializedPaymentIndicator :: !(E'SpecializedPaymentIndicator) -- ^ /Required/ "specializedPaymentIndicator"
  , k4SegmentDeferredPaymentStartDate :: !(Maybe DateTime) -- ^ "deferredPaymentStartDate"
  , k4SegmentBalloonPaymentDueDate :: !(Maybe DateTime) -- ^ "balloonPaymentDueDate"
  , k4SegmentBalloonPaymentAmount :: !(Maybe Int) -- ^ "balloonPaymentAmount"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON K4Segment
instance A.FromJSON K4Segment where
  parseJSON = A.withObject "K4Segment" $ \o ->
    K4Segment
      <$> (o .:  "segmentIdentifier")
      <*> (o .:  "specializedPaymentIndicator")
      <*> (o .:? "deferredPaymentStartDate")
      <*> (o .:? "balloonPaymentDueDate")
      <*> (o .:? "balloonPaymentAmount")

-- | ToJSON K4Segment
instance A.ToJSON K4Segment where
  toJSON K4Segment {..} =
   A.object
      [ "segmentIdentifier" .= k4SegmentSegmentIdentifier
      , "specializedPaymentIndicator" .= k4SegmentSpecializedPaymentIndicator
      , "deferredPaymentStartDate" .= k4SegmentDeferredPaymentStartDate
      , "balloonPaymentDueDate" .= k4SegmentBalloonPaymentDueDate
      , "balloonPaymentAmount" .= k4SegmentBalloonPaymentAmount
      ]


-- | Construct a value of type 'K4Segment' (by applying it's required fields, if any)
mkK4Segment
  :: E'SegmentIdentifier6 -- ^ 'k4SegmentSegmentIdentifier'
  -> E'SpecializedPaymentIndicator -- ^ 'k4SegmentSpecializedPaymentIndicator'
  -> K4Segment
mkK4Segment k4SegmentSegmentIdentifier k4SegmentSpecializedPaymentIndicator =
  K4Segment
  { k4SegmentSegmentIdentifier
  , k4SegmentSpecializedPaymentIndicator
  , k4SegmentDeferredPaymentStartDate = Nothing
  , k4SegmentBalloonPaymentDueDate = Nothing
  , k4SegmentBalloonPaymentAmount = Nothing
  }

-- ** L1Segment
-- | L1Segment
data L1Segment = L1Segment
  { l1SegmentSegmentIdentifier :: !(E'SegmentIdentifier7) -- ^ /Required/ "segmentIdentifier"
  , l1SegmentChangeIndicator :: !(Int) -- ^ /Required/ "changeIndicator"
  , l1SegmentNewConsumerAccountNumber :: !(Maybe Text) -- ^ "newConsumerAccountNumber"
  , l1SegmentBalloonPaymentDueDate :: !(Maybe Text) -- ^ "balloonPaymentDueDate"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON L1Segment
instance A.FromJSON L1Segment where
  parseJSON = A.withObject "L1Segment" $ \o ->
    L1Segment
      <$> (o .:  "segmentIdentifier")
      <*> (o .:  "changeIndicator")
      <*> (o .:? "newConsumerAccountNumber")
      <*> (o .:? "balloonPaymentDueDate")

-- | ToJSON L1Segment
instance A.ToJSON L1Segment where
  toJSON L1Segment {..} =
   A.object
      [ "segmentIdentifier" .= l1SegmentSegmentIdentifier
      , "changeIndicator" .= l1SegmentChangeIndicator
      , "newConsumerAccountNumber" .= l1SegmentNewConsumerAccountNumber
      , "balloonPaymentDueDate" .= l1SegmentBalloonPaymentDueDate
      ]


-- | Construct a value of type 'L1Segment' (by applying it's required fields, if any)
mkL1Segment
  :: E'SegmentIdentifier7 -- ^ 'l1SegmentSegmentIdentifier'
  -> Int -- ^ 'l1SegmentChangeIndicator'
  -> L1Segment
mkL1Segment l1SegmentSegmentIdentifier l1SegmentChangeIndicator =
  L1Segment
  { l1SegmentSegmentIdentifier
  , l1SegmentChangeIndicator
  , l1SegmentNewConsumerAccountNumber = Nothing
  , l1SegmentBalloonPaymentDueDate = Nothing
  }

-- ** N1Segment
-- | N1Segment
data N1Segment = N1Segment
  { n1SegmentSegmentIdentifier :: !(E'SegmentIdentifier8) -- ^ /Required/ "segmentIdentifier"
  , n1SegmentEmployerName :: !(Text) -- ^ /Required/ "employerName"
  , n1SegmentFirstLineEmployerAddress :: !(Maybe Text) -- ^ "firstLineEmployerAddress"
  , n1SegmentSecondLineEmployerAddress :: !(Maybe Text) -- ^ "secondLineEmployerAddress"
  , n1SegmentEmployerCity :: !(Maybe Text) -- ^ "employerCity"
  , n1SegmentEmployerState :: !(Maybe Text) -- ^ "employerState"
  , n1SegmentZipCode :: !(Maybe Text) -- ^ "zipCode"
  , n1SegmentOccupation :: !(Maybe Text) -- ^ "occupation"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON N1Segment
instance A.FromJSON N1Segment where
  parseJSON = A.withObject "N1Segment" $ \o ->
    N1Segment
      <$> (o .:  "segmentIdentifier")
      <*> (o .:  "employerName")
      <*> (o .:? "firstLineEmployerAddress")
      <*> (o .:? "secondLineEmployerAddress")
      <*> (o .:? "employerCity")
      <*> (o .:? "employerState")
      <*> (o .:? "zipCode")
      <*> (o .:? "occupation")

-- | ToJSON N1Segment
instance A.ToJSON N1Segment where
  toJSON N1Segment {..} =
   A.object
      [ "segmentIdentifier" .= n1SegmentSegmentIdentifier
      , "employerName" .= n1SegmentEmployerName
      , "firstLineEmployerAddress" .= n1SegmentFirstLineEmployerAddress
      , "secondLineEmployerAddress" .= n1SegmentSecondLineEmployerAddress
      , "employerCity" .= n1SegmentEmployerCity
      , "employerState" .= n1SegmentEmployerState
      , "zipCode" .= n1SegmentZipCode
      , "occupation" .= n1SegmentOccupation
      ]


-- | Construct a value of type 'N1Segment' (by applying it's required fields, if any)
mkN1Segment
  :: E'SegmentIdentifier8 -- ^ 'n1SegmentSegmentIdentifier'
  -> Text -- ^ 'n1SegmentEmployerName'
  -> N1Segment
mkN1Segment n1SegmentSegmentIdentifier n1SegmentEmployerName =
  N1Segment
  { n1SegmentSegmentIdentifier
  , n1SegmentEmployerName
  , n1SegmentFirstLineEmployerAddress = Nothing
  , n1SegmentSecondLineEmployerAddress = Nothing
  , n1SegmentEmployerCity = Nothing
  , n1SegmentEmployerState = Nothing
  , n1SegmentZipCode = Nothing
  , n1SegmentOccupation = Nothing
  }

-- ** TrailerRecord
-- | TrailerRecord
data TrailerRecord = TrailerRecord
  { trailerRecordBlockDescriptorWord :: !(Maybe Int) -- ^ "blockDescriptorWord"
  , trailerRecordRecordDescriptorWord :: !(Int) -- ^ /Required/ "recordDescriptorWord"
  , trailerRecordRecordIdentifier :: !(E'RecordIdentifier2) -- ^ /Required/ "recordIdentifier"
  , trailerRecordTotalBaseRecords :: !(Maybe Int) -- ^ "totalBaseRecords"
  , trailerRecordTotalStatusCodeDf :: !(Maybe Int) -- ^ "totalStatusCodeDF"
  , trailerRecordTotalConsumerSegmentsJ1 :: !(Maybe Int) -- ^ "totalConsumerSegmentsJ1"
  , trailerRecordTotalConsumerSegmentsJ2 :: !(Maybe Int) -- ^ "totalConsumerSegmentsJ2"
  , trailerRecordBlockCount :: !(Maybe Int) -- ^ "blockCount"
  , trailerRecordTotalStatusCodeDa :: !(Maybe Int) -- ^ "totalStatusCodeDA"
  , trailerRecordTotalStatusCode05 :: !(Maybe Int) -- ^ "totalStatusCode05"
  , trailerRecordTotalStatusCode11 :: !(Maybe Int) -- ^ "totalStatusCode11"
  , trailerRecordTotalStatusCode13 :: !(Maybe Int) -- ^ "totalStatusCode13"
  , trailerRecordTotalStatusCode61 :: !(Maybe Int) -- ^ "totalStatusCode61"
  , trailerRecordTotalStatusCode62 :: !(Maybe Int) -- ^ "totalStatusCode62"
  , trailerRecordTotalStatusCode63 :: !(Maybe Int) -- ^ "totalStatusCode63"
  , trailerRecordTotalStatusCode64 :: !(Maybe Int) -- ^ "totalStatusCode64"
  , trailerRecordTotalStatusCode65 :: !(Maybe Int) -- ^ "totalStatusCode65"
  , trailerRecordTotalStatusCode71 :: !(Maybe Int) -- ^ "totalStatusCode71"
  , trailerRecordTotalStatusCode78 :: !(Maybe Int) -- ^ "totalStatusCode78"
  , trailerRecordTotalStatusCode80 :: !(Maybe Int) -- ^ "totalStatusCode80"
  , trailerRecordTotalStatusCode82 :: !(Maybe Int) -- ^ "totalStatusCode82"
  , trailerRecordTotalStatusCode83 :: !(Maybe Int) -- ^ "totalStatusCode83"
  , trailerRecordTotalStatusCode84 :: !(Maybe Int) -- ^ "totalStatusCode84"
  , trailerRecordTotalStatusCode88 :: !(Maybe Int) -- ^ "totalStatusCode88"
  , trailerRecordTotalStatusCode89 :: !(Maybe Int) -- ^ "totalStatusCode89"
  , trailerRecordTotalStatusCode93 :: !(Maybe Int) -- ^ "totalStatusCode93"
  , trailerRecordTotalStatusCode94 :: !(Maybe Int) -- ^ "totalStatusCode94"
  , trailerRecordTotalStatusCode95 :: !(Maybe Int) -- ^ "totalStatusCode95"
  , trailerRecordTotalStatusCode96 :: !(Maybe Int) -- ^ "totalStatusCode96"
  , trailerRecordTotalStatusCode97 :: !(Maybe Int) -- ^ "totalStatusCode97"
  , trailerRecordTotalEcoaCodeZ :: !(Maybe Int) -- ^ "totalECOACodeZ"
  , trailerRecordTotalEmploymentSegments :: !(Maybe Int) -- ^ "totalEmploymentSegments"
  , trailerRecordTotalOriginalCreditorSegments :: !(Maybe Int) -- ^ "totalOriginalCreditorSegments"
  , trailerRecordTotalPurchasedToSegments :: !(Maybe Int) -- ^ "totalPurchasedToSegments"
  , trailerRecordTotalMortgageInformationSegments :: !(Maybe Int) -- ^ "totalMortgageInformationSegments"
  , trailerRecordTotalPaymentInformationSegments :: !(Maybe Int) -- ^ "totalPaymentInformationSegments"
  , trailerRecordTotalChangeSegments :: !(Maybe Int) -- ^ "totalChangeSegments"
  , trailerRecordTotalSocialNumbersAllSegments :: !(Maybe Int) -- ^ "totalSocialNumbersAllSegments"
  , trailerRecordTotalSocialNumbersBaseSegments :: !(Maybe Int) -- ^ "totalSocialNumbersBaseSegments"
  , trailerRecordTotalSocialNumbersJ1Segments :: !(Maybe Int) -- ^ "totalSocialNumbersJ1Segments"
  , trailerRecordTotalSocialNumbersJ2Segments :: !(Maybe Int) -- ^ "totalSocialNumbersJ2Segments"
  , trailerRecordTotalDatesBirthAllSegments :: !(Maybe Int) -- ^ "totalDatesBirthAllSegments"
  , trailerRecordTotalDatesBirthBaseSegments :: !(Maybe Int) -- ^ "totalDatesBirthBaseSegments"
  , trailerRecordTotalDatesBirthJ1Segments :: !(Maybe Int) -- ^ "totalDatesBirthJ1Segments"
  , trailerRecordTotalDatesBirthJ2Segments :: !(Maybe Int) -- ^ "totalDatesBirthJ2Segments"
  , trailerRecordTotalTelephoneNumbersAllSegments :: !(Maybe Int) -- ^ "totalTelephoneNumbersAllSegments"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TrailerRecord
instance A.FromJSON TrailerRecord where
  parseJSON = A.withObject "TrailerRecord" $ \o ->
    TrailerRecord
      <$> (o .:? "blockDescriptorWord")
      <*> (o .:  "recordDescriptorWord")
      <*> (o .:  "recordIdentifier")
      <*> (o .:? "totalBaseRecords")
      <*> (o .:? "totalStatusCodeDF")
      <*> (o .:? "totalConsumerSegmentsJ1")
      <*> (o .:? "totalConsumerSegmentsJ2")
      <*> (o .:? "blockCount")
      <*> (o .:? "totalStatusCodeDA")
      <*> (o .:? "totalStatusCode05")
      <*> (o .:? "totalStatusCode11")
      <*> (o .:? "totalStatusCode13")
      <*> (o .:? "totalStatusCode61")
      <*> (o .:? "totalStatusCode62")
      <*> (o .:? "totalStatusCode63")
      <*> (o .:? "totalStatusCode64")
      <*> (o .:? "totalStatusCode65")
      <*> (o .:? "totalStatusCode71")
      <*> (o .:? "totalStatusCode78")
      <*> (o .:? "totalStatusCode80")
      <*> (o .:? "totalStatusCode82")
      <*> (o .:? "totalStatusCode83")
      <*> (o .:? "totalStatusCode84")
      <*> (o .:? "totalStatusCode88")
      <*> (o .:? "totalStatusCode89")
      <*> (o .:? "totalStatusCode93")
      <*> (o .:? "totalStatusCode94")
      <*> (o .:? "totalStatusCode95")
      <*> (o .:? "totalStatusCode96")
      <*> (o .:? "totalStatusCode97")
      <*> (o .:? "totalECOACodeZ")
      <*> (o .:? "totalEmploymentSegments")
      <*> (o .:? "totalOriginalCreditorSegments")
      <*> (o .:? "totalPurchasedToSegments")
      <*> (o .:? "totalMortgageInformationSegments")
      <*> (o .:? "totalPaymentInformationSegments")
      <*> (o .:? "totalChangeSegments")
      <*> (o .:? "totalSocialNumbersAllSegments")
      <*> (o .:? "totalSocialNumbersBaseSegments")
      <*> (o .:? "totalSocialNumbersJ1Segments")
      <*> (o .:? "totalSocialNumbersJ2Segments")
      <*> (o .:? "totalDatesBirthAllSegments")
      <*> (o .:? "totalDatesBirthBaseSegments")
      <*> (o .:? "totalDatesBirthJ1Segments")
      <*> (o .:? "totalDatesBirthJ2Segments")
      <*> (o .:? "totalTelephoneNumbersAllSegments")

-- | ToJSON TrailerRecord
instance A.ToJSON TrailerRecord where
  toJSON TrailerRecord {..} =
   A.object
      [ "blockDescriptorWord" .= trailerRecordBlockDescriptorWord
      , "recordDescriptorWord" .= trailerRecordRecordDescriptorWord
      , "recordIdentifier" .= trailerRecordRecordIdentifier
      , "totalBaseRecords" .= trailerRecordTotalBaseRecords
      , "totalStatusCodeDF" .= trailerRecordTotalStatusCodeDf
      , "totalConsumerSegmentsJ1" .= trailerRecordTotalConsumerSegmentsJ1
      , "totalConsumerSegmentsJ2" .= trailerRecordTotalConsumerSegmentsJ2
      , "blockCount" .= trailerRecordBlockCount
      , "totalStatusCodeDA" .= trailerRecordTotalStatusCodeDa
      , "totalStatusCode05" .= trailerRecordTotalStatusCode05
      , "totalStatusCode11" .= trailerRecordTotalStatusCode11
      , "totalStatusCode13" .= trailerRecordTotalStatusCode13
      , "totalStatusCode61" .= trailerRecordTotalStatusCode61
      , "totalStatusCode62" .= trailerRecordTotalStatusCode62
      , "totalStatusCode63" .= trailerRecordTotalStatusCode63
      , "totalStatusCode64" .= trailerRecordTotalStatusCode64
      , "totalStatusCode65" .= trailerRecordTotalStatusCode65
      , "totalStatusCode71" .= trailerRecordTotalStatusCode71
      , "totalStatusCode78" .= trailerRecordTotalStatusCode78
      , "totalStatusCode80" .= trailerRecordTotalStatusCode80
      , "totalStatusCode82" .= trailerRecordTotalStatusCode82
      , "totalStatusCode83" .= trailerRecordTotalStatusCode83
      , "totalStatusCode84" .= trailerRecordTotalStatusCode84
      , "totalStatusCode88" .= trailerRecordTotalStatusCode88
      , "totalStatusCode89" .= trailerRecordTotalStatusCode89
      , "totalStatusCode93" .= trailerRecordTotalStatusCode93
      , "totalStatusCode94" .= trailerRecordTotalStatusCode94
      , "totalStatusCode95" .= trailerRecordTotalStatusCode95
      , "totalStatusCode96" .= trailerRecordTotalStatusCode96
      , "totalStatusCode97" .= trailerRecordTotalStatusCode97
      , "totalECOACodeZ" .= trailerRecordTotalEcoaCodeZ
      , "totalEmploymentSegments" .= trailerRecordTotalEmploymentSegments
      , "totalOriginalCreditorSegments" .= trailerRecordTotalOriginalCreditorSegments
      , "totalPurchasedToSegments" .= trailerRecordTotalPurchasedToSegments
      , "totalMortgageInformationSegments" .= trailerRecordTotalMortgageInformationSegments
      , "totalPaymentInformationSegments" .= trailerRecordTotalPaymentInformationSegments
      , "totalChangeSegments" .= trailerRecordTotalChangeSegments
      , "totalSocialNumbersAllSegments" .= trailerRecordTotalSocialNumbersAllSegments
      , "totalSocialNumbersBaseSegments" .= trailerRecordTotalSocialNumbersBaseSegments
      , "totalSocialNumbersJ1Segments" .= trailerRecordTotalSocialNumbersJ1Segments
      , "totalSocialNumbersJ2Segments" .= trailerRecordTotalSocialNumbersJ2Segments
      , "totalDatesBirthAllSegments" .= trailerRecordTotalDatesBirthAllSegments
      , "totalDatesBirthBaseSegments" .= trailerRecordTotalDatesBirthBaseSegments
      , "totalDatesBirthJ1Segments" .= trailerRecordTotalDatesBirthJ1Segments
      , "totalDatesBirthJ2Segments" .= trailerRecordTotalDatesBirthJ2Segments
      , "totalTelephoneNumbersAllSegments" .= trailerRecordTotalTelephoneNumbersAllSegments
      ]


-- | Construct a value of type 'TrailerRecord' (by applying it's required fields, if any)
mkTrailerRecord
  :: Int -- ^ 'trailerRecordRecordDescriptorWord'
  -> E'RecordIdentifier2 -- ^ 'trailerRecordRecordIdentifier'
  -> TrailerRecord
mkTrailerRecord trailerRecordRecordDescriptorWord trailerRecordRecordIdentifier =
  TrailerRecord
  { trailerRecordBlockDescriptorWord = Nothing
  , trailerRecordRecordDescriptorWord
  , trailerRecordRecordIdentifier
  , trailerRecordTotalBaseRecords = Nothing
  , trailerRecordTotalStatusCodeDf = Nothing
  , trailerRecordTotalConsumerSegmentsJ1 = Nothing
  , trailerRecordTotalConsumerSegmentsJ2 = Nothing
  , trailerRecordBlockCount = Nothing
  , trailerRecordTotalStatusCodeDa = Nothing
  , trailerRecordTotalStatusCode05 = Nothing
  , trailerRecordTotalStatusCode11 = Nothing
  , trailerRecordTotalStatusCode13 = Nothing
  , trailerRecordTotalStatusCode61 = Nothing
  , trailerRecordTotalStatusCode62 = Nothing
  , trailerRecordTotalStatusCode63 = Nothing
  , trailerRecordTotalStatusCode64 = Nothing
  , trailerRecordTotalStatusCode65 = Nothing
  , trailerRecordTotalStatusCode71 = Nothing
  , trailerRecordTotalStatusCode78 = Nothing
  , trailerRecordTotalStatusCode80 = Nothing
  , trailerRecordTotalStatusCode82 = Nothing
  , trailerRecordTotalStatusCode83 = Nothing
  , trailerRecordTotalStatusCode84 = Nothing
  , trailerRecordTotalStatusCode88 = Nothing
  , trailerRecordTotalStatusCode89 = Nothing
  , trailerRecordTotalStatusCode93 = Nothing
  , trailerRecordTotalStatusCode94 = Nothing
  , trailerRecordTotalStatusCode95 = Nothing
  , trailerRecordTotalStatusCode96 = Nothing
  , trailerRecordTotalStatusCode97 = Nothing
  , trailerRecordTotalEcoaCodeZ = Nothing
  , trailerRecordTotalEmploymentSegments = Nothing
  , trailerRecordTotalOriginalCreditorSegments = Nothing
  , trailerRecordTotalPurchasedToSegments = Nothing
  , trailerRecordTotalMortgageInformationSegments = Nothing
  , trailerRecordTotalPaymentInformationSegments = Nothing
  , trailerRecordTotalChangeSegments = Nothing
  , trailerRecordTotalSocialNumbersAllSegments = Nothing
  , trailerRecordTotalSocialNumbersBaseSegments = Nothing
  , trailerRecordTotalSocialNumbersJ1Segments = Nothing
  , trailerRecordTotalSocialNumbersJ2Segments = Nothing
  , trailerRecordTotalDatesBirthAllSegments = Nothing
  , trailerRecordTotalDatesBirthBaseSegments = Nothing
  , trailerRecordTotalDatesBirthJ1Segments = Nothing
  , trailerRecordTotalDatesBirthJ2Segments = Nothing
  , trailerRecordTotalTelephoneNumbersAllSegments = Nothing
  }


-- * Enums


-- ** E'AccountStatus

-- | Enum of 'Text'
data E'AccountStatus
  = -- | @"DF"@
    -- Delete entire account due to confirmed fraud (fraud investigation completed)
    E'AccountStatus'DF
  | -- | @"DA"@
    -- Delete entire account (for reasons other than fraud)
    -- Note:
    --  In order to maintain the integrity of credit information,
    --  it is important that data furnishers not ask for a subsequent deletion of account history unless an actual error was reported.
    --  Paid derogatory accounts, such as collections, should be reported as paid; they should not be deleted.
    E'AccountStatus'DA
  | -- | @"11"@
    -- Current account (0-29 days past the due date)
    -- For Installment and Mortgage loans, the account should be current and have a non-zero Balance Amount.
    -- For Credit Line, Open and Revolving portfolio types, the account should be current and available for use.
    -- If the account is closed, but there is a balance due,
    -- Special Comment Code M or Compliance Condition Code XA should also be reported to indicate the account is no longer available for use.
    E'AccountStatus'11
  | -- | @"13"@
    -- Paid or closed account/zero balance
    -- For Installment and Mortgage loans, the account should be paid with a zero Balance Amount.
    -- For Credit Line, Open and Revolving portfolio types, the account should no longer be available for use, and the Balance Amount should be zero.
    -- A Special Comment Code M or Compliance Condition Code XA may also be reported to indicate the account is closed.
    E'AccountStatus'13
  | -- | @"61"@
    -- Account paid in full, was a voluntary surrender
    -- Requires Current Balance and Amount Past Due = zero.
    -- Refer to Frequently Asked Question & Answer 63 for reporting guidelines.
    E'AccountStatus'61
  | -- |  @"62"@
    -- Account paid in full, was a collection account
    -- Requires Current Balance and Amount Past Due = zero.
    E'AccountStatus'62
  | -- | @"63"@
    -- Account paid in full, was a repossession
    -- Requires Current Balance and Amount Past Due = zero.
    -- Refer to Frequently Asked Question & Answer 62 for reporting guidelines.
    E'AccountStatus'63
  | -- | @"64"@
    -- Account paid in full, was a charge-off
    -- Requires Current Balance and Amount Past Due = zero.
    -- Refer to Frequently Asked Question & Answer 34(b) for reporting guidelines.
    E'AccountStatus'64
  | -- | @"65"@
    -- Account paid in full. A foreclosure was started.
    -- Requires Current Balance and Amount Past Due = zero.
    -- Refer to Frequently Asked Question & Answer 52 for reporting guidelines.
    E'AccountStatus'65
  | -- | @"71"@
    -- Account 30-59 days past the due date
    E'AccountStatus'71
  | -- | @"78"@
    -- Account 60-89 days past the due date
    E'AccountStatus'78
  | -- | @"80"@
    -- Account 90-119 days past the due date
    E'AccountStatus'80
  | -- | @"82"@
    -- Account 120-149 days past the due date
    E'AccountStatus'82
  | -- | @"83"@
    -- Account 150-179 days past the due date
    E'AccountStatus'83
  | -- | @"84"@
    -- Account 180 days or more past the due date
    E'AccountStatus'84
  | -- | @"88"@
    -- Claim filed with government for insured portion of balance on a defaulted loan
    E'AccountStatus'88
  | -- | @"89"@
    -- Deed received in lieu of foreclosure on a defaulted mortgage; there may be a balance due
    -- Refer to Frequently Asked Question & Answer 53 for reporting guidelines.
    -- Note: For credit reporting purposes, do not report Account Status Code 97 (Charge-off) after Account Status 89 has been reported.
    E'AccountStatus'89
  | -- | @"93"@
    -- Account assigned to internal or external collections
    E'AccountStatus'93
  | -- | @"94"@
    -- Foreclosure completed; there may be a balance due
    -- Refer to Frequently Asked Question & Answer 52 for reporting guidelines.
    -- Note: For credit reporting purposes, do not report Account Status Code 97 (Charge-off) after Account Status 94 has been reported.
    E'AccountStatus'94
  | -- | @"95"@
    -- Voluntary surrender; there may be a balance due
    -- Refer to Frequently Asked Question & Answer 63 for reporting guidelines.
    -- Note: Do not report Status Code 95 for early termination of leases.
    -- Refer to the Leasing category within Exhibit 6 for applicable Special Comments.
    E'AccountStatus'95
  | -- | @"96"@
    -- Merchandise was repossessed; there may be a balance due
    -- Refer to Frequently Asked Question & Answer 62 for reporting guidelines.
    E'AccountStatus'96
  | -- | @"97"@
    -- Unpaid balance reported as a loss (charge-off)
    -- Refer to Frequently Asked Questions & Answers 34(a) & (c) for reporting guidelines
    E'AccountStatus'97
  | -- | @"5"@
    -- Account transferred
    -- Requires Current Balance and Amount Past Due = zero.
    -- IMPORTANT NOTE: Account Status 05 will become obsolete for reporting in April 2022.
    -- Refer to the Transferred category within Exhibit 6 for a list of Special Comment Codes that should be used instead of Account Status 05. Refer to Frequently Asked Question & Answer 46 for guidance on reporting transferred accounts, and to Frequently Asked Question & Answer 47 for guidance on reporting sold accounts.
    E'AccountStatus'5
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'AccountStatus where toJSON = A.toJSON . fromE'AccountStatus
instance A.FromJSON E'AccountStatus where parseJSON o = P.either P.fail (pure . P.id) . toE'AccountStatus =<< A.parseJSON o
instance WH.ToHttpApiData E'AccountStatus where toQueryParam = WH.toQueryParam . fromE'AccountStatus
instance WH.FromHttpApiData E'AccountStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'AccountStatus
instance MimeRender MimeMultipartFormData E'AccountStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'AccountStatus' enum
fromE'AccountStatus :: E'AccountStatus -> Text
fromE'AccountStatus = \case
  E'AccountStatus'DF -> "DF"
  E'AccountStatus'DA -> "DA"
  E'AccountStatus'11 -> "11"
  E'AccountStatus'61 -> "61"
  E'AccountStatus'62 -> "62"
  E'AccountStatus'63 -> "63"
  E'AccountStatus'64 -> "64"
  E'AccountStatus'71 -> "71"
  E'AccountStatus'78 -> "78"
  E'AccountStatus'80 -> "80"
  E'AccountStatus'82 -> "82"
  E'AccountStatus'83 -> "83"
  E'AccountStatus'84 -> "84"
  E'AccountStatus'93 -> "93"
  E'AccountStatus'96 -> "96"
  E'AccountStatus'97 -> "97"
  E'AccountStatus'5 -> "5"
  E'AccountStatus'13 -> "13"
  E'AccountStatus'65 -> "65"
  E'AccountStatus'88 -> "88"
  E'AccountStatus'89 -> "89"
  E'AccountStatus'94 -> "94"
  E'AccountStatus'95 -> "95"

-- | parse 'E'AccountStatus' enum
toE'AccountStatus :: Text -> P.Either String E'AccountStatus
toE'AccountStatus = \case
  "DF" -> P.Right E'AccountStatus'DF
  "DA" -> P.Right E'AccountStatus'DA
  "11" -> P.Right E'AccountStatus'11
  "61" -> P.Right E'AccountStatus'61
  "62" -> P.Right E'AccountStatus'62
  "63" -> P.Right E'AccountStatus'63
  "64" -> P.Right E'AccountStatus'64
  "71" -> P.Right E'AccountStatus'71
  "78" -> P.Right E'AccountStatus'78
  "80" -> P.Right E'AccountStatus'80
  "82" -> P.Right E'AccountStatus'82
  "83" -> P.Right E'AccountStatus'83
  "84" -> P.Right E'AccountStatus'84
  "93" -> P.Right E'AccountStatus'93
  "96" -> P.Right E'AccountStatus'96
  "97" -> P.Right E'AccountStatus'97
  "5" -> P.Right E'AccountStatus'5
  "13" -> P.Right E'AccountStatus'13
  "65" -> P.Right E'AccountStatus'65
  "88" -> P.Right E'AccountStatus'88
  "89" -> P.Right E'AccountStatus'89
  "94" -> P.Right E'AccountStatus'94
  "95" -> P.Right E'AccountStatus'95
  s -> P.Left $ "toE'AccountStatus: enum parse failure: " P.++ P.show s


-- ** E'AddressIndicator

-- | Enum of 'Text'
data E'AddressIndicator
  = E'AddressIndicator'C -- ^ @"C"@
  | E'AddressIndicator'Y -- ^ @"Y"@
  | E'AddressIndicator'N -- ^ @"N"@
  | E'AddressIndicator'M -- ^ @"M"@
  | E'AddressIndicator'S -- ^ @"S"@
  | E'AddressIndicator'B -- ^ @"B"@
  | E'AddressIndicator'U -- ^ @"U"@
  | E'AddressIndicator'D -- ^ @"D"@
  | E'AddressIndicator'P -- ^ @"P"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'AddressIndicator where toJSON = A.toJSON . fromE'AddressIndicator
instance A.FromJSON E'AddressIndicator where parseJSON o = P.either P.fail (pure . P.id) . toE'AddressIndicator =<< A.parseJSON o
instance WH.ToHttpApiData E'AddressIndicator where toQueryParam = WH.toQueryParam . fromE'AddressIndicator
instance WH.FromHttpApiData E'AddressIndicator where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'AddressIndicator
instance MimeRender MimeMultipartFormData E'AddressIndicator where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'AddressIndicator' enum
fromE'AddressIndicator :: E'AddressIndicator -> Text
fromE'AddressIndicator = \case
  E'AddressIndicator'C -> "C"
  E'AddressIndicator'Y -> "Y"
  E'AddressIndicator'N -> "N"
  E'AddressIndicator'M -> "M"
  E'AddressIndicator'S -> "S"
  E'AddressIndicator'B -> "B"
  E'AddressIndicator'U -> "U"
  E'AddressIndicator'D -> "D"
  E'AddressIndicator'P -> "P"

-- | parse 'E'AddressIndicator' enum
toE'AddressIndicator :: Text -> P.Either String E'AddressIndicator
toE'AddressIndicator = \case
  "C" -> P.Right E'AddressIndicator'C
  "Y" -> P.Right E'AddressIndicator'Y
  "N" -> P.Right E'AddressIndicator'N
  "M" -> P.Right E'AddressIndicator'M
  "S" -> P.Right E'AddressIndicator'S
  "B" -> P.Right E'AddressIndicator'B
  "U" -> P.Right E'AddressIndicator'U
  "D" -> P.Right E'AddressIndicator'D
  "P" -> P.Right E'AddressIndicator'P
  s -> P.Left $ "toE'AddressIndicator: enum parse failure: " P.++ P.show s


-- ** E'AgencyIdentifier

-- | Enum of 'Int'
data E'AgencyIdentifier
  = E'AgencyIdentifier'Num0 -- ^ @0@
  | E'AgencyIdentifier'Num1 -- ^ @1@
  | E'AgencyIdentifier'Num2 -- ^ @2@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'AgencyIdentifier where toJSON = A.toJSON . fromE'AgencyIdentifier
instance A.FromJSON E'AgencyIdentifier where parseJSON o = P.either P.fail (pure . P.id) . toE'AgencyIdentifier =<< A.parseJSON o
instance WH.ToHttpApiData E'AgencyIdentifier where toQueryParam = WH.toQueryParam . fromE'AgencyIdentifier
instance WH.FromHttpApiData E'AgencyIdentifier where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'AgencyIdentifier
instance MimeRender MimeMultipartFormData E'AgencyIdentifier where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'AgencyIdentifier' enum
fromE'AgencyIdentifier :: E'AgencyIdentifier -> Int
fromE'AgencyIdentifier = \case
  E'AgencyIdentifier'Num0 -> 0
  E'AgencyIdentifier'Num1 -> 1
  E'AgencyIdentifier'Num2 -> 2

-- | parse 'E'AgencyIdentifier' enum
toE'AgencyIdentifier :: Int -> P.Either String E'AgencyIdentifier
toE'AgencyIdentifier = \case
  0 -> P.Right E'AgencyIdentifier'Num0
  1 -> P.Right E'AgencyIdentifier'Num1
  2 -> P.Right E'AgencyIdentifier'Num2
  s -> P.Left $ "toE'AgencyIdentifier: enum parse failure: " P.++ P.show s


-- ** E'CreditorClassification

-- | Enum of 'Int'
data E'CreditorClassification
  = E'CreditorClassification'Num1 -- ^ @1@
  | E'CreditorClassification'Num2 -- ^ @2@
  | E'CreditorClassification'Num3 -- ^ @3@
  | E'CreditorClassification'Num4 -- ^ @4@
  | E'CreditorClassification'Num5 -- ^ @5@
  | E'CreditorClassification'Num6 -- ^ @6@
  | E'CreditorClassification'Num7 -- ^ @7@
  | E'CreditorClassification'Num8 -- ^ @8@
  | E'CreditorClassification'Num9 -- ^ @9@
  | E'CreditorClassification'Num10 -- ^ @10@
  | E'CreditorClassification'Num11 -- ^ @11@
  | E'CreditorClassification'Num12 -- ^ @12@
  | E'CreditorClassification'Num13 -- ^ @13@
  | E'CreditorClassification'Num14 -- ^ @14@
  | E'CreditorClassification'Num15 -- ^ @15@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'CreditorClassification where toJSON = A.toJSON . fromE'CreditorClassification
instance A.FromJSON E'CreditorClassification where parseJSON o = P.either P.fail (pure . P.id) . toE'CreditorClassification =<< A.parseJSON o
instance WH.ToHttpApiData E'CreditorClassification where toQueryParam = WH.toQueryParam . fromE'CreditorClassification
instance WH.FromHttpApiData E'CreditorClassification where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'CreditorClassification
instance MimeRender MimeMultipartFormData E'CreditorClassification where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'CreditorClassification' enum
fromE'CreditorClassification :: E'CreditorClassification -> Int
fromE'CreditorClassification = \case
  E'CreditorClassification'Num1 -> 1
  E'CreditorClassification'Num2 -> 2
  E'CreditorClassification'Num3 -> 3
  E'CreditorClassification'Num4 -> 4
  E'CreditorClassification'Num5 -> 5
  E'CreditorClassification'Num6 -> 6
  E'CreditorClassification'Num7 -> 7
  E'CreditorClassification'Num8 -> 8
  E'CreditorClassification'Num9 -> 9
  E'CreditorClassification'Num10 -> 10
  E'CreditorClassification'Num11 -> 11
  E'CreditorClassification'Num12 -> 12
  E'CreditorClassification'Num13 -> 13
  E'CreditorClassification'Num14 -> 14
  E'CreditorClassification'Num15 -> 15

-- | parse 'E'CreditorClassification' enum
toE'CreditorClassification :: Int -> P.Either String E'CreditorClassification
toE'CreditorClassification = \case
  1 -> P.Right E'CreditorClassification'Num1
  2 -> P.Right E'CreditorClassification'Num2
  3 -> P.Right E'CreditorClassification'Num3
  4 -> P.Right E'CreditorClassification'Num4
  5 -> P.Right E'CreditorClassification'Num5
  6 -> P.Right E'CreditorClassification'Num6
  7 -> P.Right E'CreditorClassification'Num7
  8 -> P.Right E'CreditorClassification'Num8
  9 -> P.Right E'CreditorClassification'Num9
  10 -> P.Right E'CreditorClassification'Num10
  11 -> P.Right E'CreditorClassification'Num11
  12 -> P.Right E'CreditorClassification'Num12
  13 -> P.Right E'CreditorClassification'Num13
  14 -> P.Right E'CreditorClassification'Num14
  15 -> P.Right E'CreditorClassification'Num15
  s -> P.Left $ "toE'CreditorClassification: enum parse failure: " P.++ P.show s


-- ** E'Format

-- | Enum of 'Text' .
-- print metro2 file type
data E'Format
  = E'Format'Json -- ^ @"json"@
  | E'Format'Metro2 -- ^ @"metro2"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Format where toJSON = A.toJSON . fromE'Format
instance A.FromJSON E'Format where parseJSON o = P.either P.fail (pure . P.id) . toE'Format =<< A.parseJSON o
instance WH.ToHttpApiData E'Format where toQueryParam = WH.toQueryParam . fromE'Format
instance WH.FromHttpApiData E'Format where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Format
instance MimeRender MimeMultipartFormData E'Format where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Format' enum
fromE'Format :: E'Format -> Text
fromE'Format = \case
  E'Format'Json -> "json"
  E'Format'Metro2 -> "metro2"

-- | parse 'E'Format' enum
toE'Format :: Text -> P.Either String E'Format
toE'Format = \case
  "json" -> P.Right E'Format'Json
  "metro2" -> P.Right E'Format'Metro2
  s -> P.Left $ "toE'Format: enum parse failure: " P.++ P.show s


-- ** E'GenerationCode

-- | Enum of 'Text'
data E'GenerationCode
  = E'GenerationCode'J -- ^ @"J"@
  | E'GenerationCode'3 -- ^ @"3"@
  | E'GenerationCode'6 -- ^ @"6"@
  | E'GenerationCode'9 -- ^ @"9"@
  | E'GenerationCode'S -- ^ @"S"@
  | E'GenerationCode'4 -- ^ @"4"@
  | E'GenerationCode'7 -- ^ @"7"@
  | E'GenerationCode'2 -- ^ @"2"@
  | E'GenerationCode'5 -- ^ @"5"@
  | E'GenerationCode'8 -- ^ @"8"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'GenerationCode where toJSON = A.toJSON . fromE'GenerationCode
instance A.FromJSON E'GenerationCode where parseJSON o = P.either P.fail (pure . P.id) . toE'GenerationCode =<< A.parseJSON o
instance WH.ToHttpApiData E'GenerationCode where toQueryParam = WH.toQueryParam . fromE'GenerationCode
instance WH.FromHttpApiData E'GenerationCode where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'GenerationCode
instance MimeRender MimeMultipartFormData E'GenerationCode where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'GenerationCode' enum
fromE'GenerationCode :: E'GenerationCode -> Text
fromE'GenerationCode = \case
  E'GenerationCode'J -> "J"
  E'GenerationCode'3 -> "3"
  E'GenerationCode'6 -> "6"
  E'GenerationCode'9 -> "9"
  E'GenerationCode'S -> "S"
  E'GenerationCode'4 -> "4"
  E'GenerationCode'7 -> "7"
  E'GenerationCode'2 -> "2"
  E'GenerationCode'5 -> "5"
  E'GenerationCode'8 -> "8"

-- | parse 'E'GenerationCode' enum
toE'GenerationCode :: Text -> P.Either String E'GenerationCode
toE'GenerationCode = \case
  "J" -> P.Right E'GenerationCode'J
  "3" -> P.Right E'GenerationCode'3
  "6" -> P.Right E'GenerationCode'6
  "9" -> P.Right E'GenerationCode'9
  "S" -> P.Right E'GenerationCode'S
  "4" -> P.Right E'GenerationCode'4
  "7" -> P.Right E'GenerationCode'7
  "2" -> P.Right E'GenerationCode'2
  "5" -> P.Right E'GenerationCode'5
  "8" -> P.Right E'GenerationCode'8
  s -> P.Left $ "toE'GenerationCode: enum parse failure: " P.++ P.show s


-- ** E'GenerationCode2

-- | Enum of 'Text'
data E'GenerationCode2
  = E'GenerationCode2'J -- ^ @"J"@
  | E'GenerationCode2'S -- ^ @"S"@
  | E'GenerationCode2'2 -- ^ @"2"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'GenerationCode2 where toJSON = A.toJSON . fromE'GenerationCode2
instance A.FromJSON E'GenerationCode2 where parseJSON o = P.either P.fail (pure . P.id) . toE'GenerationCode2 =<< A.parseJSON o
instance WH.ToHttpApiData E'GenerationCode2 where toQueryParam = WH.toQueryParam . fromE'GenerationCode2
instance WH.FromHttpApiData E'GenerationCode2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'GenerationCode2
instance MimeRender MimeMultipartFormData E'GenerationCode2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'GenerationCode2' enum
fromE'GenerationCode2 :: E'GenerationCode2 -> Text
fromE'GenerationCode2 = \case
  E'GenerationCode2'J -> "J"
  E'GenerationCode2'S -> "S"
  E'GenerationCode2'2 -> "2"

-- | parse 'E'GenerationCode2' enum
toE'GenerationCode2 :: Text -> P.Either String E'GenerationCode2
toE'GenerationCode2 = \case
  "J" -> P.Right E'GenerationCode2'J
  "S" -> P.Right E'GenerationCode2'S
  "2" -> P.Right E'GenerationCode2'2
  s -> P.Left $ "toE'GenerationCode2: enum parse failure: " P.++ P.show s


-- ** E'PaymentHistoryProfile

-- | Enum of 'Text'
data E'PaymentHistoryProfile
  = E'PaymentHistoryProfile'0 -- ^ @"0"@
  | E'PaymentHistoryProfile'1 -- ^ @"1"@
  | E'PaymentHistoryProfile'2 -- ^ @"2"@
  | E'PaymentHistoryProfile'3 -- ^ @"3"@
  | E'PaymentHistoryProfile'4 -- ^ @"4"@
  | E'PaymentHistoryProfile'5 -- ^ @"5"@
  | E'PaymentHistoryProfile'6 -- ^ @"6"@
  | E'PaymentHistoryProfile'B -- ^ @"B"@
  | E'PaymentHistoryProfile'D -- ^ @"D"@
  | E'PaymentHistoryProfile'E -- ^ @"E"@
  | E'PaymentHistoryProfile'G -- ^ @"G"@
  | E'PaymentHistoryProfile'H -- ^ @"H"@
  | E'PaymentHistoryProfile'J -- ^ @"J"@
  | E'PaymentHistoryProfile'K -- ^ @"K"@
  | E'PaymentHistoryProfile'L -- ^ @"L"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'PaymentHistoryProfile where toJSON = A.toJSON . fromE'PaymentHistoryProfile
instance A.FromJSON E'PaymentHistoryProfile where parseJSON o = P.either P.fail (pure . P.id) . toE'PaymentHistoryProfile =<< A.parseJSON o
instance WH.ToHttpApiData E'PaymentHistoryProfile where toQueryParam = WH.toQueryParam . fromE'PaymentHistoryProfile
instance WH.FromHttpApiData E'PaymentHistoryProfile where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'PaymentHistoryProfile
instance MimeRender MimeMultipartFormData E'PaymentHistoryProfile where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'PaymentHistoryProfile' enum
fromE'PaymentHistoryProfile :: E'PaymentHistoryProfile -> Text
fromE'PaymentHistoryProfile = \case
  E'PaymentHistoryProfile'0 -> "0"
  E'PaymentHistoryProfile'1 -> "1"
  E'PaymentHistoryProfile'2 -> "2"
  E'PaymentHistoryProfile'3 -> "3"
  E'PaymentHistoryProfile'4 -> "4"
  E'PaymentHistoryProfile'5 -> "5"
  E'PaymentHistoryProfile'6 -> "6"
  E'PaymentHistoryProfile'B -> "B"
  E'PaymentHistoryProfile'D -> "D"
  E'PaymentHistoryProfile'E -> "E"
  E'PaymentHistoryProfile'G -> "G"
  E'PaymentHistoryProfile'H -> "H"
  E'PaymentHistoryProfile'J -> "J"
  E'PaymentHistoryProfile'K -> "K"
  E'PaymentHistoryProfile'L -> "L"

-- | parse 'E'PaymentHistoryProfile' enum
toE'PaymentHistoryProfile :: Text -> P.Either String E'PaymentHistoryProfile
toE'PaymentHistoryProfile = \case
  "0" -> P.Right E'PaymentHistoryProfile'0
  "1" -> P.Right E'PaymentHistoryProfile'1
  "2" -> P.Right E'PaymentHistoryProfile'2
  "3" -> P.Right E'PaymentHistoryProfile'3
  "4" -> P.Right E'PaymentHistoryProfile'4
  "5" -> P.Right E'PaymentHistoryProfile'5
  "6" -> P.Right E'PaymentHistoryProfile'6
  "B" -> P.Right E'PaymentHistoryProfile'B
  "D" -> P.Right E'PaymentHistoryProfile'D
  "E" -> P.Right E'PaymentHistoryProfile'E
  "G" -> P.Right E'PaymentHistoryProfile'G
  "H" -> P.Right E'PaymentHistoryProfile'H
  "J" -> P.Right E'PaymentHistoryProfile'J
  "K" -> P.Right E'PaymentHistoryProfile'K
  "L" -> P.Right E'PaymentHistoryProfile'L
  s -> P.Left $ "toE'PaymentHistoryProfile: enum parse failure: " P.++ P.show s


-- ** E'PaymentRating

-- | Enum of 'Text'
data E'PaymentRating
  = -- | @"0"@
    E'PaymentRating'0
  | -- | @"1"@
    E'PaymentRating'1
  | -- | @"2"@
    E'PaymentRating'2
  | -- | @"3"@
    E'PaymentRating'3
  | -- | @"4"@
    E'PaymentRating'4
  | -- | @"5"@
    E'PaymentRating'5
  | -- | @"6"@
    E'PaymentRating'6
  | -- | @"G"@
    E'PaymentRating'G
  | -- | @"L"@
    E'PaymentRating'L
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'PaymentRating where toJSON = A.toJSON . fromE'PaymentRating
instance A.FromJSON E'PaymentRating where parseJSON o = P.either P.fail (pure . P.id) . toE'PaymentRating =<< A.parseJSON o
instance WH.ToHttpApiData E'PaymentRating where toQueryParam = WH.toQueryParam . fromE'PaymentRating
instance WH.FromHttpApiData E'PaymentRating where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'PaymentRating
instance MimeRender MimeMultipartFormData E'PaymentRating where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'PaymentRating' enum
fromE'PaymentRating :: E'PaymentRating -> Text
fromE'PaymentRating = \case
  E'PaymentRating'0 -> "0"
  E'PaymentRating'1 -> "1"
  E'PaymentRating'2 -> "2"
  E'PaymentRating'3 -> "3"
  E'PaymentRating'4 -> "4"
  E'PaymentRating'5 -> "5"
  E'PaymentRating'6 -> "6"
  E'PaymentRating'G -> "G"
  E'PaymentRating'L -> "L"

-- | parse 'E'PaymentRating' enum
toE'PaymentRating :: Text -> P.Either String E'PaymentRating
toE'PaymentRating = \case
  "0" -> P.Right E'PaymentRating'0
  "1" -> P.Right E'PaymentRating'1
  "2" -> P.Right E'PaymentRating'2
  "3" -> P.Right E'PaymentRating'3
  "4" -> P.Right E'PaymentRating'4
  "5" -> P.Right E'PaymentRating'5
  "6" -> P.Right E'PaymentRating'6
  "G" -> P.Right E'PaymentRating'G
  "L" -> P.Right E'PaymentRating'L
  s -> P.Left $ "toE'PaymentRating: enum parse failure: " P.++ P.show s


-- ** E'PortfolioType

-- | Enum of 'Text'
data E'PortfolioType
  = E'PortfolioType'C -- ^ @"C"@
  | E'PortfolioType'I -- ^ @"I"@
  | E'PortfolioType'M -- ^ @"M"@
  | E'PortfolioType'O -- ^ @"O"@
  | E'PortfolioType'R -- ^ @"R"@
  | E'PortfolioType'L -- ^ @"L"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'PortfolioType where toJSON = A.toJSON . fromE'PortfolioType
instance A.FromJSON E'PortfolioType where parseJSON o = P.either P.fail (pure . P.id) . toE'PortfolioType =<< A.parseJSON o
instance WH.ToHttpApiData E'PortfolioType where toQueryParam = WH.toQueryParam . fromE'PortfolioType
instance WH.FromHttpApiData E'PortfolioType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'PortfolioType
instance MimeRender MimeMultipartFormData E'PortfolioType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'PortfolioType' enum
fromE'PortfolioType :: E'PortfolioType -> Text
fromE'PortfolioType = \case
  E'PortfolioType'C -> "C"
  E'PortfolioType'I -> "I"
  E'PortfolioType'M -> "M"
  E'PortfolioType'O -> "O"
  E'PortfolioType'R -> "R"
  E'PortfolioType'L -> "L"

-- | parse 'E'PortfolioType' enum
toE'PortfolioType :: Text -> P.Either String E'PortfolioType
toE'PortfolioType = \case
  "C" -> P.Right E'PortfolioType'C
  "I" -> P.Right E'PortfolioType'I
  "M" -> P.Right E'PortfolioType'M
  "O" -> P.Right E'PortfolioType'O
  "R" -> P.Right E'PortfolioType'R
  "L" -> P.Right E'PortfolioType'L
  s -> P.Left $ "toE'PortfolioType: enum parse failure: " P.++ P.show s


-- ** E'PurchasedIndicator

-- | Enum of 'Int'
data E'PurchasedIndicator
  = E'PurchasedIndicator'Num1 -- ^ @1@
  | E'PurchasedIndicator'Num2 -- ^ @2@
  | E'PurchasedIndicator'Num9 -- ^ @9@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'PurchasedIndicator where toJSON = A.toJSON . fromE'PurchasedIndicator
instance A.FromJSON E'PurchasedIndicator where parseJSON o = P.either P.fail (pure . P.id) . toE'PurchasedIndicator =<< A.parseJSON o
instance WH.ToHttpApiData E'PurchasedIndicator where toQueryParam = WH.toQueryParam . fromE'PurchasedIndicator
instance WH.FromHttpApiData E'PurchasedIndicator where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'PurchasedIndicator
instance MimeRender MimeMultipartFormData E'PurchasedIndicator where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'PurchasedIndicator' enum
fromE'PurchasedIndicator :: E'PurchasedIndicator -> Int
fromE'PurchasedIndicator = \case
  E'PurchasedIndicator'Num1 -> 1
  E'PurchasedIndicator'Num2 -> 2
  E'PurchasedIndicator'Num9 -> 9

-- | parse 'E'PurchasedIndicator' enum
toE'PurchasedIndicator :: Int -> P.Either String E'PurchasedIndicator
toE'PurchasedIndicator = \case
  1 -> P.Right E'PurchasedIndicator'Num1
  2 -> P.Right E'PurchasedIndicator'Num2
  9 -> P.Right E'PurchasedIndicator'Num9
  s -> P.Left $ "toE'PurchasedIndicator: enum parse failure: " P.++ P.show s


-- ** E'RecordIdentifier

-- | Enum of 'Text'
data E'RecordIdentifier
  = E'RecordIdentifier'HEADER -- ^ @"HEADER"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'RecordIdentifier where toJSON = A.toJSON . fromE'RecordIdentifier
instance A.FromJSON E'RecordIdentifier where parseJSON o = P.either P.fail (pure . P.id) . toE'RecordIdentifier =<< A.parseJSON o
instance WH.ToHttpApiData E'RecordIdentifier where toQueryParam = WH.toQueryParam . fromE'RecordIdentifier
instance WH.FromHttpApiData E'RecordIdentifier where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'RecordIdentifier
instance MimeRender MimeMultipartFormData E'RecordIdentifier where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'RecordIdentifier' enum
fromE'RecordIdentifier :: E'RecordIdentifier -> Text
fromE'RecordIdentifier = \case
  E'RecordIdentifier'HEADER -> "HEADER"

-- | parse 'E'RecordIdentifier' enum
toE'RecordIdentifier :: Text -> P.Either String E'RecordIdentifier
toE'RecordIdentifier = \case
  "HEADER" -> P.Right E'RecordIdentifier'HEADER
  s -> P.Left $ "toE'RecordIdentifier: enum parse failure: " P.++ P.show s


-- ** E'RecordIdentifier2

-- | Enum of 'Text'
data E'RecordIdentifier2
  = E'RecordIdentifier2'TRAILER -- ^ @"TRAILER"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'RecordIdentifier2 where toJSON = A.toJSON . fromE'RecordIdentifier2
instance A.FromJSON E'RecordIdentifier2 where parseJSON o = P.either P.fail (pure . P.id) . toE'RecordIdentifier2 =<< A.parseJSON o
instance WH.ToHttpApiData E'RecordIdentifier2 where toQueryParam = WH.toQueryParam . fromE'RecordIdentifier2
instance WH.FromHttpApiData E'RecordIdentifier2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'RecordIdentifier2
instance MimeRender MimeMultipartFormData E'RecordIdentifier2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'RecordIdentifier2' enum
fromE'RecordIdentifier2 :: E'RecordIdentifier2 -> Text
fromE'RecordIdentifier2 = \case
  E'RecordIdentifier2'TRAILER -> "TRAILER"

-- | parse 'E'RecordIdentifier2' enum
toE'RecordIdentifier2 :: Text -> P.Either String E'RecordIdentifier2
toE'RecordIdentifier2 = \case
  "TRAILER" -> P.Right E'RecordIdentifier2'TRAILER
  s -> P.Left $ "toE'RecordIdentifier2: enum parse failure: " P.++ P.show s


-- ** E'ResidenceCode

-- | Enum of 'Text'
data E'ResidenceCode
  = E'ResidenceCode'O -- ^ @"O"@
  | E'ResidenceCode'R -- ^ @"R"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ResidenceCode where toJSON = A.toJSON . fromE'ResidenceCode
instance A.FromJSON E'ResidenceCode where parseJSON o = P.either P.fail (pure . P.id) . toE'ResidenceCode =<< A.parseJSON o
instance WH.ToHttpApiData E'ResidenceCode where toQueryParam = WH.toQueryParam . fromE'ResidenceCode
instance WH.FromHttpApiData E'ResidenceCode where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ResidenceCode
instance MimeRender MimeMultipartFormData E'ResidenceCode where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ResidenceCode' enum
fromE'ResidenceCode :: E'ResidenceCode -> Text
fromE'ResidenceCode = \case
  E'ResidenceCode'O -> "O"
  E'ResidenceCode'R -> "R"

-- | parse 'E'ResidenceCode' enum
toE'ResidenceCode :: Text -> P.Either String E'ResidenceCode
toE'ResidenceCode = \case
  "O" -> P.Right E'ResidenceCode'O
  "R" -> P.Right E'ResidenceCode'R
  s -> P.Left $ "toE'ResidenceCode: enum parse failure: " P.++ P.show s


-- ** E'SegmentIdentifier

-- | Enum of 'Text'
data E'SegmentIdentifier
  = E'SegmentIdentifier'J1 -- ^ @"J1"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'SegmentIdentifier where toJSON = A.toJSON . fromE'SegmentIdentifier
instance A.FromJSON E'SegmentIdentifier where parseJSON o = P.either P.fail (pure . P.id) . toE'SegmentIdentifier =<< A.parseJSON o
instance WH.ToHttpApiData E'SegmentIdentifier where toQueryParam = WH.toQueryParam . fromE'SegmentIdentifier
instance WH.FromHttpApiData E'SegmentIdentifier where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'SegmentIdentifier
instance MimeRender MimeMultipartFormData E'SegmentIdentifier where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'SegmentIdentifier' enum
fromE'SegmentIdentifier :: E'SegmentIdentifier -> Text
fromE'SegmentIdentifier = \case
  E'SegmentIdentifier'J1 -> "J1"

-- | parse 'E'SegmentIdentifier' enum
toE'SegmentIdentifier :: Text -> P.Either String E'SegmentIdentifier
toE'SegmentIdentifier = \case
  "J1" -> P.Right E'SegmentIdentifier'J1
  s -> P.Left $ "toE'SegmentIdentifier: enum parse failure: " P.++ P.show s


-- ** E'SegmentIdentifier2

-- | Enum of 'Text'
data E'SegmentIdentifier2
  = E'SegmentIdentifier2'J2 -- ^ @"J2"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'SegmentIdentifier2 where toJSON = A.toJSON . fromE'SegmentIdentifier2
instance A.FromJSON E'SegmentIdentifier2 where parseJSON o = P.either P.fail (pure . P.id) . toE'SegmentIdentifier2 =<< A.parseJSON o
instance WH.ToHttpApiData E'SegmentIdentifier2 where toQueryParam = WH.toQueryParam . fromE'SegmentIdentifier2
instance WH.FromHttpApiData E'SegmentIdentifier2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'SegmentIdentifier2
instance MimeRender MimeMultipartFormData E'SegmentIdentifier2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'SegmentIdentifier2' enum
fromE'SegmentIdentifier2 :: E'SegmentIdentifier2 -> Text
fromE'SegmentIdentifier2 = \case
  E'SegmentIdentifier2'J2 -> "J2"

-- | parse 'E'SegmentIdentifier2' enum
toE'SegmentIdentifier2 :: Text -> P.Either String E'SegmentIdentifier2
toE'SegmentIdentifier2 = \case
  "J2" -> P.Right E'SegmentIdentifier2'J2
  s -> P.Left $ "toE'SegmentIdentifier2: enum parse failure: " P.++ P.show s


-- ** E'SegmentIdentifier3

-- | Enum of 'Text'
data E'SegmentIdentifier3
  = E'SegmentIdentifier3'K1 -- ^ @"K1"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'SegmentIdentifier3 where toJSON = A.toJSON . fromE'SegmentIdentifier3
instance A.FromJSON E'SegmentIdentifier3 where parseJSON o = P.either P.fail (pure . P.id) . toE'SegmentIdentifier3 =<< A.parseJSON o
instance WH.ToHttpApiData E'SegmentIdentifier3 where toQueryParam = WH.toQueryParam . fromE'SegmentIdentifier3
instance WH.FromHttpApiData E'SegmentIdentifier3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'SegmentIdentifier3
instance MimeRender MimeMultipartFormData E'SegmentIdentifier3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'SegmentIdentifier3' enum
fromE'SegmentIdentifier3 :: E'SegmentIdentifier3 -> Text
fromE'SegmentIdentifier3 = \case
  E'SegmentIdentifier3'K1 -> "K1"

-- | parse 'E'SegmentIdentifier3' enum
toE'SegmentIdentifier3 :: Text -> P.Either String E'SegmentIdentifier3
toE'SegmentIdentifier3 = \case
  "K1" -> P.Right E'SegmentIdentifier3'K1
  s -> P.Left $ "toE'SegmentIdentifier3: enum parse failure: " P.++ P.show s


-- ** E'SegmentIdentifier4

-- | Enum of 'Text'
data E'SegmentIdentifier4
  = E'SegmentIdentifier4'K2 -- ^ @"K2"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'SegmentIdentifier4 where toJSON = A.toJSON . fromE'SegmentIdentifier4
instance A.FromJSON E'SegmentIdentifier4 where parseJSON o = P.either P.fail (pure . P.id) . toE'SegmentIdentifier4 =<< A.parseJSON o
instance WH.ToHttpApiData E'SegmentIdentifier4 where toQueryParam = WH.toQueryParam . fromE'SegmentIdentifier4
instance WH.FromHttpApiData E'SegmentIdentifier4 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'SegmentIdentifier4
instance MimeRender MimeMultipartFormData E'SegmentIdentifier4 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'SegmentIdentifier4' enum
fromE'SegmentIdentifier4 :: E'SegmentIdentifier4 -> Text
fromE'SegmentIdentifier4 = \case
  E'SegmentIdentifier4'K2 -> "K2"

-- | parse 'E'SegmentIdentifier4' enum
toE'SegmentIdentifier4 :: Text -> P.Either String E'SegmentIdentifier4
toE'SegmentIdentifier4 = \case
  "K2" -> P.Right E'SegmentIdentifier4'K2
  s -> P.Left $ "toE'SegmentIdentifier4: enum parse failure: " P.++ P.show s


-- ** E'SegmentIdentifier5

-- | Enum of 'Text'
data E'SegmentIdentifier5
  = E'SegmentIdentifier5'K3 -- ^ @"K3"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'SegmentIdentifier5 where toJSON = A.toJSON . fromE'SegmentIdentifier5
instance A.FromJSON E'SegmentIdentifier5 where parseJSON o = P.either P.fail (pure . P.id) . toE'SegmentIdentifier5 =<< A.parseJSON o
instance WH.ToHttpApiData E'SegmentIdentifier5 where toQueryParam = WH.toQueryParam . fromE'SegmentIdentifier5
instance WH.FromHttpApiData E'SegmentIdentifier5 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'SegmentIdentifier5
instance MimeRender MimeMultipartFormData E'SegmentIdentifier5 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'SegmentIdentifier5' enum
fromE'SegmentIdentifier5 :: E'SegmentIdentifier5 -> Text
fromE'SegmentIdentifier5 = \case
  E'SegmentIdentifier5'K3 -> "K3"

-- | parse 'E'SegmentIdentifier5' enum
toE'SegmentIdentifier5 :: Text -> P.Either String E'SegmentIdentifier5
toE'SegmentIdentifier5 = \case
  "K3" -> P.Right E'SegmentIdentifier5'K3
  s -> P.Left $ "toE'SegmentIdentifier5: enum parse failure: " P.++ P.show s


-- ** E'SegmentIdentifier6

-- | Enum of 'Text'
data E'SegmentIdentifier6
  = E'SegmentIdentifier6'K4 -- ^ @"K4"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'SegmentIdentifier6 where toJSON = A.toJSON . fromE'SegmentIdentifier6
instance A.FromJSON E'SegmentIdentifier6 where parseJSON o = P.either P.fail (pure . P.id) . toE'SegmentIdentifier6 =<< A.parseJSON o
instance WH.ToHttpApiData E'SegmentIdentifier6 where toQueryParam = WH.toQueryParam . fromE'SegmentIdentifier6
instance WH.FromHttpApiData E'SegmentIdentifier6 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'SegmentIdentifier6
instance MimeRender MimeMultipartFormData E'SegmentIdentifier6 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'SegmentIdentifier6' enum
fromE'SegmentIdentifier6 :: E'SegmentIdentifier6 -> Text
fromE'SegmentIdentifier6 = \case
  E'SegmentIdentifier6'K4 -> "K4"

-- | parse 'E'SegmentIdentifier6' enum
toE'SegmentIdentifier6 :: Text -> P.Either String E'SegmentIdentifier6
toE'SegmentIdentifier6 = \case
  "K4" -> P.Right E'SegmentIdentifier6'K4
  s -> P.Left $ "toE'SegmentIdentifier6: enum parse failure: " P.++ P.show s


-- ** E'SegmentIdentifier7

-- | Enum of 'Text'
data E'SegmentIdentifier7
  = E'SegmentIdentifier7'L1 -- ^ @"L1"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'SegmentIdentifier7 where toJSON = A.toJSON . fromE'SegmentIdentifier7
instance A.FromJSON E'SegmentIdentifier7 where parseJSON o = P.either P.fail (pure . P.id) . toE'SegmentIdentifier7 =<< A.parseJSON o
instance WH.ToHttpApiData E'SegmentIdentifier7 where toQueryParam = WH.toQueryParam . fromE'SegmentIdentifier7
instance WH.FromHttpApiData E'SegmentIdentifier7 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'SegmentIdentifier7
instance MimeRender MimeMultipartFormData E'SegmentIdentifier7 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'SegmentIdentifier7' enum
fromE'SegmentIdentifier7 :: E'SegmentIdentifier7 -> Text
fromE'SegmentIdentifier7 = \case
  E'SegmentIdentifier7'L1 -> "L1"

-- | parse 'E'SegmentIdentifier7' enum
toE'SegmentIdentifier7 :: Text -> P.Either String E'SegmentIdentifier7
toE'SegmentIdentifier7 = \case
  "L1" -> P.Right E'SegmentIdentifier7'L1
  s -> P.Left $ "toE'SegmentIdentifier7: enum parse failure: " P.++ P.show s


-- ** E'SegmentIdentifier8

-- | Enum of 'Text'
data E'SegmentIdentifier8
  = E'SegmentIdentifier8'N1 -- ^ @"N1"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'SegmentIdentifier8 where toJSON = A.toJSON . fromE'SegmentIdentifier8
instance A.FromJSON E'SegmentIdentifier8 where parseJSON o = P.either P.fail (pure . P.id) . toE'SegmentIdentifier8 =<< A.parseJSON o
instance WH.ToHttpApiData E'SegmentIdentifier8 where toQueryParam = WH.toQueryParam . fromE'SegmentIdentifier8
instance WH.FromHttpApiData E'SegmentIdentifier8 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'SegmentIdentifier8
instance MimeRender MimeMultipartFormData E'SegmentIdentifier8 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'SegmentIdentifier8' enum
fromE'SegmentIdentifier8 :: E'SegmentIdentifier8 -> Text
fromE'SegmentIdentifier8 = \case
  E'SegmentIdentifier8'N1 -> "N1"

-- | parse 'E'SegmentIdentifier8' enum
toE'SegmentIdentifier8 :: Text -> P.Either String E'SegmentIdentifier8
toE'SegmentIdentifier8 = \case
  "N1" -> P.Right E'SegmentIdentifier8'N1
  s -> P.Left $ "toE'SegmentIdentifier8: enum parse failure: " P.++ P.show s


-- ** E'SpecializedPaymentIndicator

-- | Enum of 'Int'
data E'SpecializedPaymentIndicator
  = E'SpecializedPaymentIndicator'Num1 -- ^ @1@
  | E'SpecializedPaymentIndicator'Num2 -- ^ @2@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'SpecializedPaymentIndicator where toJSON = A.toJSON . fromE'SpecializedPaymentIndicator
instance A.FromJSON E'SpecializedPaymentIndicator where parseJSON o = P.either P.fail (pure . P.id) . toE'SpecializedPaymentIndicator =<< A.parseJSON o
instance WH.ToHttpApiData E'SpecializedPaymentIndicator where toQueryParam = WH.toQueryParam . fromE'SpecializedPaymentIndicator
instance WH.FromHttpApiData E'SpecializedPaymentIndicator where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'SpecializedPaymentIndicator
instance MimeRender MimeMultipartFormData E'SpecializedPaymentIndicator where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'SpecializedPaymentIndicator' enum
fromE'SpecializedPaymentIndicator :: E'SpecializedPaymentIndicator -> Int
fromE'SpecializedPaymentIndicator = \case
  E'SpecializedPaymentIndicator'Num1 -> 1
  E'SpecializedPaymentIndicator'Num2 -> 2

-- | parse 'E'SpecializedPaymentIndicator' enum
toE'SpecializedPaymentIndicator :: Int -> P.Either String E'SpecializedPaymentIndicator
toE'SpecializedPaymentIndicator = \case
  1 -> P.Right E'SpecializedPaymentIndicator'Num1
  2 -> P.Right E'SpecializedPaymentIndicator'Num2
  s -> P.Left $ "toE'SpecializedPaymentIndicator: enum parse failure: " P.++ P.show s


-- ** E'TermsFrequency

-- | Enum of 'Text'
data E'TermsFrequency
  = E'TermsFrequency'D -- ^ @"D"@
  | E'TermsFrequency'P -- ^ @"P"@
  | E'TermsFrequency'W -- ^ @"W"@
  | E'TermsFrequency'B -- ^ @"B"@
  | E'TermsFrequency'E -- ^ @"E"@
  | E'TermsFrequency'M -- ^ @"M"@
  | E'TermsFrequency'L -- ^ @"L"@
  | E'TermsFrequency'Q -- ^ @"Q"@
  | E'TermsFrequency'T -- ^ @"T"@
  | E'TermsFrequency'S -- ^ @"S"@
  | E'TermsFrequency'Y -- ^ @"Y"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'TermsFrequency where toJSON = A.toJSON . fromE'TermsFrequency
instance A.FromJSON E'TermsFrequency where parseJSON o = P.either P.fail (pure . P.id) . toE'TermsFrequency =<< A.parseJSON o
instance WH.ToHttpApiData E'TermsFrequency where toQueryParam = WH.toQueryParam . fromE'TermsFrequency
instance WH.FromHttpApiData E'TermsFrequency where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'TermsFrequency
instance MimeRender MimeMultipartFormData E'TermsFrequency where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'TermsFrequency' enum
fromE'TermsFrequency :: E'TermsFrequency -> Text
fromE'TermsFrequency = \case
  E'TermsFrequency'D -> "D"
  E'TermsFrequency'P -> "P"
  E'TermsFrequency'W -> "W"
  E'TermsFrequency'B -> "B"
  E'TermsFrequency'E -> "E"
  E'TermsFrequency'M -> "M"
  E'TermsFrequency'L -> "L"
  E'TermsFrequency'Q -> "Q"
  E'TermsFrequency'T -> "T"
  E'TermsFrequency'S -> "S"
  E'TermsFrequency'Y -> "Y"

-- | parse 'E'TermsFrequency' enum
toE'TermsFrequency :: Text -> P.Either String E'TermsFrequency
toE'TermsFrequency = \case
  "D" -> P.Right E'TermsFrequency'D
  "P" -> P.Right E'TermsFrequency'P
  "W" -> P.Right E'TermsFrequency'W
  "B" -> P.Right E'TermsFrequency'B
  "E" -> P.Right E'TermsFrequency'E
  "M" -> P.Right E'TermsFrequency'M
  "L" -> P.Right E'TermsFrequency'L
  "Q" -> P.Right E'TermsFrequency'Q
  "T" -> P.Right E'TermsFrequency'T
  "S" -> P.Right E'TermsFrequency'S
  "Y" -> P.Right E'TermsFrequency'Y
  s -> P.Left $ "toE'TermsFrequency: enum parse failure: " P.++ P.show s


-- ** E'Type

-- | Enum of 'Text' .
-- metro file type
data E'Type
  = E'Type'Character -- ^ @"character"@
  | E'Type'Packed -- ^ @"packed"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type where toJSON = A.toJSON . fromE'Type
instance A.FromJSON E'Type where parseJSON o = P.either P.fail (pure . P.id) . toE'Type =<< A.parseJSON o
instance WH.ToHttpApiData E'Type where toQueryParam = WH.toQueryParam . fromE'Type
instance WH.FromHttpApiData E'Type where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type
instance MimeRender MimeMultipartFormData E'Type where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type' enum
fromE'Type :: E'Type -> Text
fromE'Type = \case
  E'Type'Character -> "character"
  E'Type'Packed -> "packed"

-- | parse 'E'Type' enum
toE'Type :: Text -> P.Either String E'Type
toE'Type = \case
  "character" -> P.Right E'Type'Character
  "packed" -> P.Right E'Type'Packed
  s -> P.Left $ "toE'Type: enum parse failure: " P.++ P.show s



